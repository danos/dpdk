From fe3ea6322c168233da914b2b4ea21b15e13b725f Mon Sep 17 00:00:00 2001
From: Alan Robertson <alan.robertson@intl.att.com>
Date: Fri, 9 Feb 2018 10:04:25 +0000
Subject: [PATCH] Improve the shaper accuracy for large packets

There were 2 issues, the first was time could be lost whilst updating
the traffic-class period, the second was a frame could be delayed if
not enough tokens were available for the full frame.  By allowing the
shaper to borrow credit from the next period the throughput is improved.

Signed-off-by: Alan Robertson <alan.robertson@intl.att.com>
---
--- a/lib/librte_sched/rte_sched.c
+++ b/lib/librte_sched/rte_sched.c
@@ -57,7 +57,7 @@ struct rte_sched_subport {
 	/* Traffic classes (TCs) */
 	uint64_t tc_time; /* time of next update */
 	uint32_t tc_credits_per_period[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-	uint32_t tc_credits[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	int32_t tc_credits[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
 	uint16_t qsize[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
 	uint32_t tc_period;
 
@@ -108,7 +108,7 @@ struct rte_sched_pipe {
 
 	/* Traffic classes (TCs) */
 	uint64_t tc_time; /* time of next update */
-	uint32_t tc_credits[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	int32_t tc_credits[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
 
 	/* Weighted Round Robin (WRR) */
 	uint32_t wrr_tokens[RTE_SCHED_QUEUES_PER_PIPE];
@@ -1794,35 +1794,62 @@ grinder_credits_update(struct rte_sched_
 	struct rte_sched_pipe_profile *params = grinder->pipe_params;
 	uint64_t n_periods;
 	uint32_t tc;
+	uint64_t lapsed;
 
 	/* Subport TB */
-	n_periods = (port->time - subport->tb_time) / subport->tb_period;
+	n_periods = (port->time_cpu_bytes - subport->tb_time) / subport->tb_period;
 	subport->tb_credits += n_periods * subport->tb_credits_per_period;
 	subport->tb_credits = rte_sched_min_val_2_u32(subport->tb_credits, subport->tb_size);
 	subport->tb_time += n_periods * subport->tb_period;
 
 	/* Pipe TB */
-	n_periods = (port->time - pipe->tb_time) / params->tb_period;
+	n_periods = (port->time_cpu_bytes - pipe->tb_time) / params->tb_period;
 	pipe->tb_credits += n_periods * params->tb_credits_per_period;
 	pipe->tb_credits = rte_sched_min_val_2_u32(pipe->tb_credits, params->tb_size);
 	pipe->tb_time += n_periods * params->tb_period;
 
 	/* Subport TCs */
-	if (unlikely(port->time >= subport->tc_time)) {
+	if (unlikely(port->time_cpu_bytes >= subport->tc_time)) {
 		for (tc = 0; tc < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; tc++) {
-			subport->tc_credits[tc] =
-				subport->tc_credits_per_period[tc];
+			if (subport->tc_credits[tc] < 0)
+				subport->tc_credits[tc] +=
+					subport->tc_credits_per_period[tc];
+			else
+				subport->tc_credits[tc] =
+					subport->tc_credits_per_period[tc];
 		}
-		subport->tc_time = port->time + subport->tc_period;
+		/* If we've run into the next period only update the clock to
+		 * the time + tc_period so we'll replenish the tc tokens early
+		 * in the next tc_period to compensate.
+		 */
+		lapsed = port->time_cpu_bytes - subport->tc_time;
+		if (lapsed < subport->tc_period)
+			subport->tc_time += subport->tc_period;
+		else
+			subport->tc_time = port->time_cpu_bytes +
+						subport->tc_period;
 	}
 
 	/* Pipe TCs */
-	if (unlikely(port->time >= pipe->tc_time)) {
+	if (unlikely(port->time_cpu_bytes >= pipe->tc_time)) {
 		for (tc = 0; tc < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; tc++) {
-			pipe->tc_credits[tc] =
-				params->tc_credits_per_period[tc];
+			if (pipe->tc_credits[tc] < 0)
+				pipe->tc_credits[tc] +=
+					params->tc_credits_per_period[tc];
+			else
+				pipe->tc_credits[tc] =
+					params->tc_credits_per_period[tc];
 		}
-		pipe->tc_time = port->time + params->tc_period;
+		/* If we've run into the next period only update the clock to
+		 * the time + tc_period so we'll replenish the tc tokens early
+		 * in the next tc_period to compensate.
+		 */
+		lapsed = port->time_cpu_bytes - pipe->tc_time;
+		if (lapsed < params->tc_period)
+			pipe->tc_time += params->tc_period;
+		else
+			pipe->tc_time = port->time_cpu_bytes +
+						params->tc_period;
 	}
 }
 
@@ -1933,19 +1960,19 @@ grinder_credits_check(struct rte_sched_p
 	uint32_t tc_index = grinder->tc_index;
 	int32_t pkt_len = pkt->pkt_len + port->frame_overhead;
 	uint32_t subport_tb_credits = subport->tb_credits;
-	uint32_t subport_tc_credits = subport->tc_credits[tc_index];
+	int32_t subport_tc_credits = subport->tc_credits[tc_index];
 	uint32_t pipe_tb_credits = pipe->tb_credits;
-	uint32_t pipe_tc_credits = pipe->tc_credits[tc_index];
+	int32_t pipe_tc_credits = pipe->tc_credits[tc_index];
 	int enough_credits;
 
 	if (pkt_len < 0)
 		pkt_len = 0;
 
 	/* Check queue credits */
-	enough_credits = (pkt_len <= subport_tb_credits) &&
-		(pkt_len <= subport_tc_credits) &&
-		(pkt_len <= pipe_tb_credits) &&
-		(pkt_len <= pipe_tc_credits);
+	enough_credits = (pkt_len <= (int32_t)subport_tb_credits) &&
+		(subport_tc_credits > 0) &&
+		(pkt_len <= (int32_t)pipe_tb_credits) &&
+		(pipe_tc_credits > 0);
 
 	if (!enough_credits)
 		return 0;
@@ -1953,8 +1980,8 @@ grinder_credits_check(struct rte_sched_p
 	/* Update port credits */
 	subport->tb_credits -= pkt_len;
 	subport->tc_credits[tc_index] -= pkt_len;
-	pipe->tb_credits -= pkt_len;
 	pipe->tc_credits[tc_index] -= pkt_len;
+	pipe->tb_credits -= pkt_len;
 
 	return 1;
 }
--- a/lib/librte_sched/rte_sched.h
+++ b/lib/librte_sched/rte_sched.h
@@ -127,14 +127,14 @@ extern "C" {
  */
 struct rte_sched_subport_params {
 	/* Subport token bucket */
-	uint32_t tb_rate;                /**< Rate (measured in bytes per second) */
-	uint32_t tb_size;                /**< Size (measured in credits) */
-
+	uint64_t tb_rate;                /**< Rate (measured in bytes per second) */
 	/* Subport traffic classes */
-	uint32_t tc_rate[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	uint64_t tc_rate[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
 	/**< Traffic class rates (measured in bytes per second) */
 	uint32_t tc_period;
 	/**< Enforcement period for rates (measured in milliseconds) */
+	/* Subport token bucket burst size */
+	uint32_t tb_size;                /**< Size (measured in credits) */
 };
 
 /** Subport statistics */
