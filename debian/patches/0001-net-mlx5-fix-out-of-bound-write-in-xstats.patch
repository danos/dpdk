From 58fdae8314a5d6f1ce295ae2c6cae506aa9367b6 Mon Sep 17 00:00:00 2001
From: "Charles (Chas) Williams" <ciwillia@vyatta.att-mail.com>
Date: Sun, 24 May 2020 15:40:53 -0400
Subject: [PATCH] net/mlx5: fix out-of-bound write in xstats

One way to determine the number of extended statisitics available is to
query to a length of 0. However, when xstats is not yet initialized,
this passes the initial check aginst the known mlx5 statistics (also
zero at this point). Later, when the counters are finally read, they
are written back to the temporary stack copy that was allocated with
a length of 0.

To fix this, pass down to mlx5_read_dev_counters what is really
available for writing.

Fixes: a4193ae3bc4f ("net/mlx5: support extended statistics")
Cc: stable@dpdk.org

Signed-off-by: Chas Williams <3chas3@gmail.com>
---
 drivers/net/mlx5/mlx5_stats.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

--- a/drivers/net/mlx5/mlx5_stats.c
+++ b/drivers/net/mlx5/mlx5_stats.c
@@ -52,7 +52,7 @@ mlx5_xstats_get(struct rte_eth_dev *dev,
 			return stats_n;
 		if (xstats_ctrl->stats_n != stats_n)
 			mlx5_os_stats_init(dev);
-		ret = mlx5_os_read_dev_counters(dev, counters);
+		ret = mlx5_os_read_dev_counters(dev, counters, mlx5_stats_n);
 		if (ret)
 			return ret;
 		for (i = 0; i != mlx5_stats_n; ++i) {
@@ -238,7 +238,7 @@ mlx5_xstats_reset(struct rte_eth_dev *de
 		rte_errno = ENOMEM;
 		return -rte_errno;
 	}
-	ret = mlx5_os_read_dev_counters(dev, counters);
+	ret = mlx5_os_read_dev_counters(dev, counters, xstats_ctrl->stats_n);
 	if (ret) {
 		DRV_LOG(ERR, "port %u cannot read device counters: %s",
 			dev->data->port_id, strerror(rte_errno));
--- a/drivers/net/mlx5/linux/mlx5_ethdev_os.c
+++ b/drivers/net/mlx5/linux/mlx5_ethdev_os.c
@@ -1246,7 +1246,8 @@ int mlx5_get_module_eeprom(struct rte_et
  *   rte_errno is set.
  */
 int
-mlx5_os_read_dev_counters(struct rte_eth_dev *dev, uint64_t *stats)
+mlx5_os_read_dev_counters(struct rte_eth_dev *dev, uint64_t *stats,
+			  uint16_t mlx5_stats_n)
 {
 	struct mlx5_priv *priv = dev->data->dev_private;
 	struct mlx5_xstats_ctrl *xstats_ctrl = &priv->xstats_ctrl;
@@ -1267,7 +1268,7 @@ mlx5_os_read_dev_counters(struct rte_eth
 			dev->data->port_id);
 		return ret;
 	}
-	for (i = 0; i != xstats_ctrl->mlx5_stats_n; ++i) {
+	for (i = 0; i != mlx5_stats_n; ++i) {
 		if (xstats_ctrl->info[i].dev) {
 			ret = mlx5_os_read_dev_stat(priv,
 					    xstats_ctrl->info[i].ctr_name,
@@ -1508,7 +1509,8 @@ mlx5_os_stats_init(struct rte_eth_dev *d
 	MLX5_ASSERT(xstats_ctrl->mlx5_stats_n <= MLX5_MAX_XSTATS);
 	xstats_ctrl->stats_n = dev_stats_n;
 	/* Copy to base at first time. */
-	ret = mlx5_os_read_dev_counters(dev, xstats_ctrl->base);
+	ret = mlx5_os_read_dev_counters(dev, xstats_ctrl->base,
+					xstats_ctrl->mlx5_stats_n);
 	if (ret)
 		DRV_LOG(ERR, "port %u cannot read device counters: %s",
 			dev->data->port_id, strerror(rte_errno));
--- a/drivers/net/mlx5/mlx5.h
+++ b/drivers/net/mlx5/mlx5.h
@@ -1104,7 +1104,8 @@ int mlx5_get_module_eeprom(struct rte_et
 			   struct rte_dev_eeprom_info *info);
 int mlx5_os_read_dev_stat(struct mlx5_priv *priv,
 			  const char *ctr_name, uint64_t *stat);
-int mlx5_os_read_dev_counters(struct rte_eth_dev *dev, uint64_t *stats);
+int mlx5_os_read_dev_counters(struct rte_eth_dev *dev, uint64_t *stats,
+			      uint16_t mlx5_stats_n);
 int mlx5_os_get_stats_n(struct rte_eth_dev *dev);
 void mlx5_os_stats_init(struct rte_eth_dev *dev);
 
