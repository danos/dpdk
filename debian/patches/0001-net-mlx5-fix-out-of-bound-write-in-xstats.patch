From 58fdae8314a5d6f1ce295ae2c6cae506aa9367b6 Mon Sep 17 00:00:00 2001
From: "Charles (Chas) Williams" <ciwillia@vyatta.att-mail.com>
Date: Sun, 24 May 2020 15:40:53 -0400
Subject: [PATCH] net/mlx5: fix out-of-bound write in xstats

One way to determine the number of extended statisitics available is to
query to a length of 0. However, when xstats is not yet initialized,
this passes the initial check aginst the known mlx5 statistics (also
zero at this point). Later, when the counters are finally read, they
are written back to the temporary stack copy that was allocated with
a length of 0.

To fix this, pass down to mlx5_read_dev_counters what is really
available for writing.

Fixes: a4193ae3bc4f ("net/mlx5: support extended statistics")
Cc: stable@dpdk.org

Signed-off-by: Chas Williams <3chas3@gmail.com>
---
 drivers/net/mlx5/mlx5_stats.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

--- a/drivers/net/mlx5/mlx5_stats.c
+++ b/drivers/net/mlx5/mlx5_stats.c
@@ -171,7 +171,8 @@ mlx5_read_ib_stat(struct mlx5_priv *priv
  *   rte_errno is set.
  */
 static int
-mlx5_read_dev_counters(struct rte_eth_dev *dev, uint64_t *stats)
+mlx5_read_dev_counters(struct rte_eth_dev *dev, uint64_t *stats,
+		       uint16_t mlx5_stats_n)
 {
 	struct mlx5_priv *priv = dev->data->dev_private;
 	struct mlx5_xstats_ctrl *xstats_ctrl = &priv->xstats_ctrl;
@@ -192,7 +193,7 @@ mlx5_read_dev_counters(struct rte_eth_de
 			dev->data->port_id);
 		return ret;
 	}
-	for (i = 0; i != xstats_ctrl->mlx5_stats_n; ++i) {
+	for (i = 0; i != mlx5_stats_n; ++i) {
 		if (xstats_ctrl->info[i].ib) {
 			mlx5_read_ib_stat(priv, xstats_ctrl->info[i].ctr_name,
 					  &stats[i]);
@@ -306,7 +307,8 @@ mlx5_stats_init(struct rte_eth_dev *dev)
 	assert(xstats_ctrl->mlx5_stats_n <= MLX5_MAX_XSTATS);
 	xstats_ctrl->stats_n = dev_stats_n;
 	/* Copy to base at first time. */
-	ret = mlx5_read_dev_counters(dev, xstats_ctrl->base);
+	ret = mlx5_read_dev_counters(dev, xstats_ctrl->base,
+				     xstats_ctrl->mlx5_stats_n);
 	if (ret)
 		DRV_LOG(ERR, "port %u cannot read device counters: %s",
 			dev->data->port_id, strerror(rte_errno));
@@ -348,7 +350,7 @@ mlx5_xstats_get(struct rte_eth_dev *dev,
 			return stats_n;
 		if (xstats_ctrl->stats_n != stats_n)
 			mlx5_stats_init(dev);
-		ret = mlx5_read_dev_counters(dev, counters);
+		ret = mlx5_read_dev_counters(dev, counters, mlx5_stats_n);
 		if (ret)
 			return ret;
 		for (i = 0; i != mlx5_stats_n; ++i) {
@@ -494,7 +496,7 @@ mlx5_xstats_reset(struct rte_eth_dev *de
 	}
 	if (xstats_ctrl->stats_n != stats_n)
 		mlx5_stats_init(dev);
-	ret = mlx5_read_dev_counters(dev, counters);
+	ret = mlx5_read_dev_counters(dev, counters, n);
 	if (ret) {
 		DRV_LOG(ERR, "port %u cannot read device counters: %s",
 			dev->data->port_id, strerror(rte_errno));
