--- a/lib/librte_sched/rte_approx.c
+++ b/lib/librte_sched/rte_approx.c
@@ -205,8 +205,9 @@ int rte_approx_get(uint32_t numerator, u
 	return rv;
 }
 
-int rte_approx_int(uint32_t numerator, uint32_t denominator,
-		   uint32_t *p, uint32_t *q)
+int __rte_experimental
+rte_approx_int(uint32_t numerator, uint32_t denominator,
+	       uint32_t *p, uint32_t *q)
 {
 	/*
 	 * The best value proved to be 16383 from the following range tried:
--- a/lib/librte_sched/rte_approx.h
+++ b/lib/librte_sched/rte_approx.h
@@ -20,6 +20,7 @@ extern "C" {
  ***/
 
 #include <stdint.h>
+#include <rte_compat.h>
 
 /**
  * Find best rational approximation
@@ -55,7 +56,8 @@ int rte_approx(double alpha, double d, u
  * @return
  *   0 upon success, error code otherwise
  */
-int rte_approx_int(uint32_t alpha_num, uint32_t denum, uint32_t *p, uint32_t *q);
+int __rte_experimental
+rte_approx_int(uint32_t alpha_num, uint32_t denum, uint32_t *p, uint32_t *q);
 
 #ifdef __cplusplus
 }
--- a/lib/librte_sched/rte_sched_version.map
+++ b/lib/librte_sched/rte_sched_version.map
@@ -61,4 +61,5 @@ EXPERIMENTAL {
 	global:
 
 	rte_sched_port_pipe_profile_add;
+	rte_approx_int;
 };
--- a/test/test/Makefile
+++ b/test/test/Makefile
@@ -150,6 +150,7 @@ SRCS-$(CONFIG_RTE_LIBRTE_NET) += test_cr
 
 ifeq ($(CONFIG_RTE_LIBRTE_SCHED),y)
 SRCS-y += test_red.c
+SRCS-y += test_rte_approx_int.c
 SRCS-y += test_sched.c
 endif
 
--- a/test/test/autotest_data.py
+++ b/test/test/autotest_data.py
@@ -243,6 +243,12 @@ parallel_test_list = [
         "Report":  None,
     },
     {
+        "Name":    "Sched approxtest",
+        "Command": "sched_approxtest",
+        "Func":    default_autotest,
+        "Report":  None,
+    },
+    {
         "Name":    "Eventdev selftest octeontx",
         "Command": "eventdev_selftest_octeontx",
         "Func":    default_autotest,
--- a/test/test/meson.build
+++ b/test/test/meson.build
@@ -76,6 +76,7 @@ test_sources = files('commands.c',
 	'test_pmd_perf.c',
 	'test_pmd_ring.c',
 	'test_pmd_ring_perf.c',
+	'test_rte_approx_int.c',
 	'test_power.c',
 	'test_power_acpi_cpufreq.c',
 	'test_power_kvm_vm.c',
@@ -224,6 +225,7 @@ test_names = [
 	'ring_pmd_perf_autotest',
 	'rwlock_autotest',
 	'sched_autotest',
+	'sched_approxtest',
 	'service_autotest',
 	'spinlock_autotest',
 	'string_autotest',
--- /dev/null
+++ b/test/test/test_rte_approx_int.c
@@ -0,0 +1,139 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2020 Intel Corporation
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdio.h>
+
+#include "test.h"
+
+#include <rte_approx.h>
+
+uint32_t linerates[] = {
+	1250000000, // 10Gbit/sec in bytes/sec
+	625000000,  // 5Gbit/sec in bytes/sec
+	312500000,  // 2.5Gbit/sec in bytes/sec
+	125000000,  // 1Gbit/sec in bytes/sec
+	12500000,   // 100Mbit/sec in bytes/sec
+	1250000,    // 10Mbit/sec in bytes/sec
+};
+
+uint32_t shape_incs[] = {
+	12500000,   // 100M bits/sec
+	1250000,    // 10M bits/sec
+	625000,     // 5M bits/sec
+	62500,      // 500000 bits/sec
+	12500,      // 100000 bits/sec
+	6250,       // 50000 bits/sec
+	1000,       // 8000 bits/sec
+};
+
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+
+static int
+test_func(uint32_t line_rate, uint32_t shape_rate, uint32_t burst)
+{
+	uint32_t creds;
+	uint32_t period;
+	uint32_t burst_tolerance;
+	int err;
+
+	err = rte_approx_int(shape_rate, line_rate, &creds, &period);
+	if (err) {
+		printf("rte_approx_int failed at shape rate: %u line rate: "
+		       "%u\n",
+		       shape_rate, line_rate);
+		return -1;
+	}
+
+	burst_tolerance = burst * 120 / 100;
+	if (burst != 0 && creds > burst_tolerance) {
+		printf("credits %u > burst-tolerance %u at shape rate: %u "
+		       "line rate: %u\n",
+		       creds, burst_tolerance, shape_rate, line_rate);
+		return -1;
+	}
+
+	double bas_perc = (double)(shape_rate)/(double)line_rate;
+	double comp = (double)creds/(double)period;
+
+	if (bas_perc < comp) {
+		printf("shape/line: %lf < credits/period %lf at shape rate: "
+		       "%u line rate: %u\n",
+		       bas_perc, comp, shape_rate, line_rate);
+		return -1;
+	}
+	return 0;
+}
+
+static int
+test_rte_approx_int(void)
+{
+	uint32_t i, j, k;
+	uint32_t shape_rate, burst;
+	int err;
+
+	/* Test rate - 1 / rate ie maximum possible */
+	printf("\n\nTesting maximum shape rates...\n\n");
+	for (i = 0; i < ARRAY_SIZE(linerates); i++) {
+		err = test_func(linerates[i], linerates[i] - 1, 0);
+		if (err) {
+			printf("Max-rate test failed at line rate %u\n",
+			       linerates[i]);
+			return -1;
+		}
+	}
+
+	printf("\n\nTesting other shape rates...\n\n");
+
+	for (i = 0; i < ARRAY_SIZE(shape_incs); i++) {
+		shape_rate = shape_incs[i];
+		for (j = 0; j < ARRAY_SIZE(linerates); j++) {
+			while (shape_rate < linerates[j]) {
+				/* 1 to 10ms for each shape/linerate combo */
+				for (k = 1; k < 11; k++) {
+					burst = shape_rate * k / 1000;
+					if (burst < 1522)
+						burst = 1522;
+
+					err = test_func(linerates[j],
+							shape_rate, burst);
+					if (err) {
+						printf("Other rate test failed line: %u, shape: %u, burst: %u\n",
+						       linerates[j], shape_rate,
+						       burst);
+						return -1;
+					}
+				}
+				shape_rate += shape_incs[i];
+			}
+		}
+	}
+
+	printf("\n\nTesting small shape/large line rates...\n\n");
+
+	for (i = 0; i < 3; i++) {
+		shape_rate = shape_incs[4];
+		for (j = 1; j < 10; j++) {
+			burst = shape_rate / 1000;
+			if (burst < 1522)
+                              burst = 1522;
+
+			err = test_func(linerates[i], shape_rate, burst);
+			if (err) {
+				printf("Low shape rate test failed line: %u, shape: %u, burst: %u\n",
+				       linerates[i], shape_rate, burst);
+				return -1;
+			}
+			/* 37500 is 300kbits increments */
+			shape_rate += j * 37500;
+		}
+	}
+	return 0;
+}
+
+REGISTER_TEST_COMMAND(sched_approxtest, test_rte_approx_int);
+
+
+
--- a/debian/librte-sched18.11.symbols
+++ b/debian/librte-sched18.11.symbols
@@ -30,6 +30,7 @@ librte_sched.so.18.11 librte-sched18.11
  rte_sched_port_get_memory_footprint@DPDK_2.0 16.04
  rte_sched_port_get_memory_footprint_v2@DPDK_17.11 17.11-0vyatta1~
  rte_sched_port_pipe_profile_add@EXPERIMENTAL 18.05
+ rte_approx_int@EXPERIMENTAL 18.05
  rte_sched_port_pkt_read_color@DPDK_2.1 16.04
  rte_sched_port_pkt_read_tree_path@DPDK_2.1 16.04
  rte_sched_port_pkt_write@DPDK_2.1 16.04
