--- a/lib/librte_acl/acl.h
+++ b/lib/librte_acl/acl.h
@@ -156,6 +156,19 @@
 	struct rte_acl_node *trie;
 };
 
+struct rte_acl_rt_ctx {
+	uint32_t            num_tries;
+	uint32_t            match_index;
+	uint64_t            no_match;
+	uint64_t            idle;
+	uint64_t           *trans_table;
+	uint32_t           *data_indexes;
+	struct rte_acl_trie trie[RTE_ACL_MAX_TRIES];
+	void               *mem;
+	size_t              mem_sz;
+	struct rte_acl_config config; /* copy of build config. */
+};
+
 struct rte_acl_ctx {
 	char                name[RTE_ACL_NAMESIZE];
 	/** Name of the ACL context. */
@@ -177,19 +190,7 @@
 	uint32_t            num_rules;
 	uint32_t            num_categories;
 
-	/* below here: all RT related fields.
-	 * get reset by acl_build_reset.
-	 */
-	uint32_t            num_tries;
-	uint32_t            match_index;
-	uint64_t            no_match;
-	uint64_t            idle;
-	uint64_t           *trans_table;
-	uint32_t           *data_indexes;
-	struct rte_acl_trie trie[RTE_ACL_MAX_TRIES];
-	void               *mem;
-	size_t              mem_sz;
-	struct rte_acl_config config; /* copy of build config. */
+	struct rte_acl_rt_ctx *rcx;
 };
 
 int rte_acl_gen(struct rte_acl_ctx *ctx, struct rte_acl_trie *trie,
--- a/lib/librte_acl/acl_bld.c
+++ b/lib/librte_acl/acl_bld.c
@@ -765,19 +765,6 @@
 	return 0;
 }
 
-/*
- * Reset current runtime fields before next build:
- *  - free allocated RT memory.
- *  - reset all RT related fields to zero.
- */
-static void
-acl_build_reset(struct rte_acl_ctx *ctx)
-{
-	rte_free(ctx->mem);
-	memset(&ctx->num_categories, 0,
-		sizeof(*ctx) - offsetof(struct rte_acl_ctx, num_categories));
-}
-
 static void
 acl_gen_full_range(struct acl_build_context *context, struct rte_acl_node *root,
 	struct rte_acl_node *end, int size, int level)
@@ -1503,7 +1490,7 @@
  * Copy data_indexes for each trie into RT location.
  */
 static void
-acl_set_data_indexes(struct rte_acl_ctx *ctx)
+acl_set_data_indexes(struct rte_acl_rt_ctx *ctx)
 {
 	uint32_t i, n, ofs;
 
@@ -1614,13 +1601,14 @@
 	uint32_t n;
 	size_t max_size;
 	struct acl_build_context bcx;
+	uint32_t data_index_sz;
+
+	data_index_sz = sizeof(((struct rte_acl_rt_ctx *)0)->data_indexes[0]);
 
 	rc = acl_check_bld_param(ctx, cfg);
 	if (rc != 0)
 		return rc;
 
-	acl_build_reset(ctx);
-
 	if (ctx->num_rules == 0)
 		return 0;
 
@@ -1642,13 +1630,13 @@
 			rc = rte_acl_gen(ctx, bcx.tries, bcx.bld_tries,
 				bcx.num_tries, bcx.cfg.num_categories,
 				RTE_ACL_MAX_FIELDS * RTE_DIM(bcx.tries) *
-				sizeof(ctx->data_indexes[0]), max_size);
+				data_index_sz, max_size);
 			if (rc == 0) {
 				/* set data indexes. */
-				acl_set_data_indexes(ctx);
+				acl_set_data_indexes(ctx->rcx);
 
 				/* copy in build config. */
-				ctx->config = *cfg;
+				ctx->rcx->config = *cfg;
 			}
 		}
 
--- a/lib/librte_acl/acl_gen.c
+++ b/lib/librte_acl/acl_gen.c
@@ -52,7 +52,7 @@
 		indices->dfa_index * sizeof(uint64_t),
 		counts->match,
 		counts->match * sizeof(struct rte_acl_match_results),
-		ctx->mem_sz,
+		ctx->rcx->mem_sz,
 		max_size);
 }
 
@@ -456,6 +456,7 @@
 	struct rte_acl_match_results *match;
 	struct acl_node_counters counts;
 	struct rte_acl_indices indices;
+	struct rte_acl_rt_ctx *rcx, *prev_rcx = ctx->rcx;
 
 	no_match = RTE_ACL_NODE_MATCH;
 
@@ -486,6 +487,15 @@
 		return -ENOMEM;
 	}
 
+	rcx = rte_zmalloc_socket("ACL_RT_CTX", sizeof(struct rte_acl_rt_ctx),
+				  RTE_CACHE_LINE_SIZE, ctx->socket_id);
+	if (rcx == NULL) {
+		RTE_LOG(ERR, ACL,
+			"allocation of runtime ACL ctx on socket %d for %s failed\n",
+			ctx->socket_id, ctx->name);
+		return -ENOMEM;
+	}
+
 	/* Fill the runtime structure */
 	match_index = indices.match_start;
 	node_array = (uint64_t *)((uintptr_t)mem +
@@ -516,16 +526,25 @@
 			trie[n].root_index = node_bld_trie[n].trie->node_index;
 	}
 
-	ctx->mem = mem;
-	ctx->mem_sz = total_size;
-	ctx->data_indexes = mem;
-	ctx->num_tries = num_tries;
 	ctx->num_categories = num_categories;
-	ctx->match_index = match_index;
-	ctx->no_match = no_match;
-	ctx->idle = node_array[RTE_ACL_DFA_SIZE];
-	ctx->trans_table = node_array;
-	memcpy(ctx->trie, trie, sizeof(ctx->trie));
+
+	rcx->mem = mem;
+	rcx->mem_sz = total_size;
+	rcx->data_indexes = mem;
+	rcx->num_tries = num_tries;
+	rcx->match_index = match_index;
+	rcx->no_match = no_match;
+	rcx->idle = node_array[RTE_ACL_DFA_SIZE];
+	rcx->trans_table = node_array;
+	memcpy(rcx->trie, trie, sizeof(rcx->trie));
+
+	/* This is not thread-safe. */
+	if (prev_rcx) {
+		rte_free(prev_rcx->mem);
+		rte_free(prev_rcx);
+	}
+
+	ctx->rcx = rcx;
 
 	acl_gen_log_stats(ctx, &counts, &indices, max_size);
 	return 0;
--- a/lib/librte_acl/acl_run.h
+++ b/lib/librte_acl/acl_run.h
@@ -108,7 +108,7 @@
  */
 static inline void
 resolve_single_priority(uint64_t transition, int n,
-	const struct rte_acl_ctx *ctx, struct parms *parms,
+	const struct rte_acl_rt_ctx *ctx, struct parms *parms,
 	const struct rte_acl_match_results *p)
 {
 	if (parms[n].cmplt->count == ctx->num_tries ||
@@ -126,7 +126,7 @@
  */
 static inline uint64_t
 acl_start_next_trie(struct acl_flow_data *flows, struct parms *parms, int n,
-	const struct rte_acl_ctx *ctx)
+	const struct rte_acl_rt_ctx *ctx)
 {
 	uint64_t transition;
 
@@ -190,7 +190,7 @@
 }
 
 typedef void (*resolve_priority_t)
-(uint64_t transition, int n, const struct rte_acl_ctx *ctx,
+(uint64_t transition, int n, const struct rte_acl_rt_ctx *ctx,
 	struct parms *parms, const struct rte_acl_match_results *p,
 	uint32_t categories);
 
@@ -201,7 +201,7 @@
  */
 static inline uint64_t
 acl_match_check(uint64_t transition, int slot,
-	const struct rte_acl_ctx *ctx, struct parms *parms,
+	const struct rte_acl_rt_ctx *ctx, struct parms *parms,
 	struct acl_flow_data *flows, resolve_priority_t resolve_priority)
 {
 	const struct rte_acl_match_results *p;
--- a/lib/librte_acl/acl_run_avx2.c
+++ b/lib/librte_acl/acl_run_avx2.c
@@ -10,9 +10,11 @@
  * both compiler and target cpu have to support AVX2 instructions.
  */
 int
-rte_acl_classify_avx2(const struct rte_acl_ctx *ctx, const uint8_t **data,
+rte_acl_classify_avx2(const struct rte_acl_ctx *acx, const uint8_t **data,
 	uint32_t *results, uint32_t num, uint32_t categories)
 {
+	struct rte_acl_rt_ctx *ctx = acx->rcx;
+
 	if (likely(num >= MAX_SEARCHES_AVX16))
 		return search_avx2x16(ctx, data, results, num, categories);
 	else if (num >= MAX_SEARCHES_SSE8)
@@ -20,6 +22,6 @@
 	else if (num >= MAX_SEARCHES_SSE4)
 		return search_sse_4(ctx, data, results, num, categories);
 	else
-		return rte_acl_classify_scalar(ctx, data, results, num,
+		return rte_acl_classify_scalar(acx, data, results, num,
 			categories);
 }
--- a/lib/librte_acl/acl_run_avx2.h
+++ b/lib/librte_acl/acl_run_avx2.h
@@ -87,7 +87,7 @@
  * tr_hi contains high 32 bits for 8 transition.
  */
 static inline void
-acl_process_matches_avx2x8(const struct rte_acl_ctx *ctx,
+acl_process_matches_avx2x8(const struct rte_acl_rt_ctx *ctx,
 	struct parms *parms, struct acl_flow_data *flows, uint32_t slot,
 	ymm_t matches, ymm_t *tr_lo, ymm_t *tr_hi)
 {
@@ -131,7 +131,7 @@
 }
 
 static inline void
-acl_match_check_avx2x8(const struct rte_acl_ctx *ctx, struct parms *parms,
+acl_match_check_avx2x8(const struct rte_acl_rt_ctx *ctx, struct parms *parms,
 	struct acl_flow_data *flows, uint32_t slot,
 	ymm_t *tr_lo, ymm_t *tr_hi, ymm_t match_mask)
 {
@@ -157,7 +157,7 @@
  * Execute trie traversal for up to 16 flows in parallel.
  */
 static inline int
-search_avx2x16(const struct rte_acl_ctx *ctx, const uint8_t **data,
+search_avx2x16(const struct rte_acl_rt_ctx *ctx, const uint8_t **data,
 	uint32_t *results, uint32_t total_packets, uint32_t categories)
 {
 	uint32_t n;
--- a/lib/librte_acl/acl_run_scalar.c
+++ b/lib/librte_acl/acl_run_scalar.c
@@ -13,7 +13,7 @@
  */
 static inline void
 resolve_priority_scalar(uint64_t transition, int n,
-	const struct rte_acl_ctx *ctx, struct parms *parms,
+	const struct rte_acl_rt_ctx *ctx, struct parms *parms,
 	const struct rte_acl_match_results *p, uint32_t categories)
 {
 	uint32_t i;
@@ -107,7 +107,7 @@
 }
 
 int
-rte_acl_classify_scalar(const struct rte_acl_ctx *ctx, const uint8_t **data,
+rte_acl_classify_scalar(const struct rte_acl_ctx *acx, const uint8_t **data,
 	uint32_t *results, uint32_t num, uint32_t categories)
 {
 	int n;
@@ -117,6 +117,7 @@
 	uint64_t index_array[MAX_SEARCHES_SCALAR];
 	struct completion cmplt[MAX_SEARCHES_SCALAR];
 	struct parms parms[MAX_SEARCHES_SCALAR];
+	struct rte_acl_rt_ctx *ctx = acx->rcx;
 
 	acl_set_flow(&flows, cmplt, RTE_DIM(cmplt), data, results, num,
 		categories, ctx->trans_table);
--- a/lib/librte_acl/acl_run_sse.h
+++ b/lib/librte_acl/acl_run_sse.h
@@ -52,9 +52,9 @@
  * its priority for each category.
  */
 static inline void
-resolve_priority_sse(uint64_t transition, int n, const struct rte_acl_ctx *ctx,
-	struct parms *parms, const struct rte_acl_match_results *p,
-	uint32_t categories)
+resolve_priority_sse(uint64_t transition, int n,
+	const struct rte_acl_rt_ctx *ctx, struct parms *parms,
+	const struct rte_acl_match_results *p, uint32_t categories)
 {
 	uint32_t x;
 	xmm_t results, priority, results1, priority1, selector;
@@ -96,7 +96,7 @@
  * Extract transitions from an XMM register and check for any matches
  */
 static void
-acl_process_matches(xmm_t *indices, int slot, const struct rte_acl_ctx *ctx,
+acl_process_matches(xmm_t *indices, int slot, const struct rte_acl_rt_ctx *ctx,
 	struct parms *parms, struct acl_flow_data *flows)
 {
 	uint64_t transition1, transition2;
@@ -121,9 +121,9 @@
  * Check for any match in 4 transitions (contained in 2 SSE registers)
  */
 static __rte_always_inline void
-acl_match_check_x4(int slot, const struct rte_acl_ctx *ctx, struct parms *parms,
-	struct acl_flow_data *flows, xmm_t *indices1, xmm_t *indices2,
-	xmm_t match_mask)
+acl_match_check_x4(int slot, const struct rte_acl_rt_ctx *ctx,
+	struct parms *parms, struct acl_flow_data *flows, xmm_t *indices1,
+	xmm_t *indices2, xmm_t match_mask)
 {
 	xmm_t temp;
 
@@ -191,7 +191,7 @@
  * Execute trie traversal with 8 traversals in parallel
  */
 static inline int
-search_sse_8(const struct rte_acl_ctx *ctx, const uint8_t **data,
+search_sse_8(const struct rte_acl_rt_ctx *ctx, const uint8_t **data,
 	uint32_t *results, uint32_t total_packets, uint32_t categories)
 {
 	int n;
@@ -280,7 +280,7 @@
  * Execute trie traversal with 4 traversals in parallel
  */
 static inline int
-search_sse_4(const struct rte_acl_ctx *ctx, const uint8_t **data,
+search_sse_4(const struct rte_acl_rt_ctx *ctx, const uint8_t **data,
 	 uint32_t *results, int total_packets, uint32_t categories)
 {
 	int n;
--- a/lib/librte_acl/rte_acl.c
+++ b/lib/librte_acl/rte_acl.c
@@ -205,7 +205,11 @@
 
 	rte_mcfg_tailq_write_unlock();
 
-	rte_free(ctx->mem);
+	if (ctx->rcx) {
+		rte_free(ctx->rcx->mem);
+		rte_free(ctx->rcx);
+	}
+
 	if (ctx->ht)
 		rte_hash_free(ctx->ht);
 	rte_free(ctx);
@@ -646,9 +650,12 @@
 void
 rte_acl_reset(struct rte_acl_ctx *ctx)
 {
+	struct rte_acl_rt_ctx *rcx;
+
 	if (ctx != NULL) {
+		rcx = ctx->rcx;
 		rte_acl_reset_rules(ctx);
-		rte_acl_build(ctx, &ctx->config);
+		rte_acl_build(ctx, rcx ? &rcx->config: NULL);
 	}
 }
 
@@ -667,7 +674,7 @@
 	printf("  rule_size=%"PRIu32"\n", ctx->rule_sz);
 	printf("  num_rules=%"PRIu32"\n", ctx->num_rules);
 	printf("  num_categories=%"PRIu32"\n", ctx->num_categories);
-	printf("  num_tries=%"PRIu32"\n", ctx->num_tries);
+	printf("  num_tries=%"PRIu32"\n", ctx->rcx ? ctx->rcx->num_tries: 0);
 	printf("  flags=%u\n", ctx->flags);
 }
 
--- a/lib/librte_acl/acl_run_sse.c
+++ b/lib/librte_acl/acl_run_sse.c
@@ -9,9 +9,9 @@
 	uint32_t *results, uint32_t num, uint32_t categories)
 {
 	if (likely(num >= MAX_SEARCHES_SSE8))
-		return search_sse_8(ctx, data, results, num, categories);
+		return search_sse_8(ctx->rcx, data, results, num, categories);
 	else if (num >= MAX_SEARCHES_SSE4)
-		return search_sse_4(ctx, data, results, num, categories);
+		return search_sse_4(ctx->rcx, data, results, num, categories);
 	else
 		return rte_acl_classify_scalar(ctx, data, results, num,
 			categories);
