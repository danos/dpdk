--- a/lib/librte_acl/rte_acl.h
+++ b/lib/librte_acl/rte_acl.h
@@ -220,6 +220,25 @@ int
 rte_acl_del_rule(struct rte_acl_ctx *ctx, const struct rte_acl_rule *rule);
 
 /**
+ * Copy rules from src context to dest context
+ * This function is not multi-thread safe
+ * This function is used to copy the build time array of rules maintained
+ * within the acl context to a new context to enable a merge of contexts
+ *
+ * @param dst_ctx
+ *  Destination context to add rules to
+ * @param src_ctx
+ *  Source context to copy rules from
+ * @return
+ *  - -ENOMEM - if there is no space in the ACL context for these rules
+ *  - -EINVAL if the parameters are invalid
+ *  - Zero if the operation completed successfully.
+ */
+int
+rte_acl_copy_rules(struct rte_acl_ctx *dst_ctx,
+		   const struct rte_acl_ctx *src_ctx);
+
+/**
  * Delete all rules from the ACL context.
  * This function is not multi-thread safe.
  * Note that internal run-time structures are not affected.
--- a/lib/librte_acl/rte_acl.c
+++ b/lib/librte_acl/rte_acl.c
@@ -659,17 +659,14 @@ acl_check_rule(const struct rte_acl_rule
 	return 0;
 }
 
-int
-rte_acl_add_rules(struct rte_acl_ctx *ctx, const struct rte_acl_rule *rules,
-	uint32_t num)
+static int
+acl_check_rules(struct rte_acl_ctx *ctx, const struct rte_acl_rule *rules,
+		uint32_t num)
 {
 	const struct rte_acl_rule *rv;
 	uint32_t i;
 	int32_t rc;
 
-	if (ctx == NULL || rules == NULL || 0 == ctx->rule_sz)
-		return -EINVAL;
-
 	for (i = 0; i != num; i++) {
 		rv = (const struct rte_acl_rule *)
 			((uintptr_t)rules + i * ctx->rule_sz);
@@ -681,9 +678,136 @@ rte_acl_add_rules(struct rte_acl_ctx *ct
 		}
 	}
 
+	return 0;
+}
+
+int
+rte_acl_add_rules(struct rte_acl_ctx *ctx, const struct rte_acl_rule *rules,
+	uint32_t num)
+{
+	const struct rte_acl_rule *rv;
+	uint32_t i;
+	int32_t rc;
+
+	if (ctx == NULL || rules == NULL || 0 == ctx->rule_sz)
+		return -EINVAL;
+
+	rc = acl_check_rules(ctx, rules, num);
+	if (rc)
+		return rc;
+
 	return acl_add_rules(ctx, rules, num);
 }
 
+static int
+acl_copy_rules_ht(struct rte_acl_ctx *dst_ctx,
+		  const struct rte_acl_ctx *src_ctx)
+{
+
+#define MAX_BATCH 512
+	uint32_t bulk_sz, nb_rules;
+	uint32_t iter = 0, nb_copied = 0;
+	struct rte_acl_rule *src_rule, *rule;
+	struct rte_acl_rule *rules[MAX_BATCH];
+	int err, ret;
+	void *key;
+
+	if (!dst_ctx->ht || !dst_ctx->rule_pool || !src_ctx->ht)
+		return -EINVAL;
+
+	nb_rules = src_ctx->num_rules;
+
+	if (rte_mempool_avail_count(dst_ctx->rule_pool) < nb_rules)
+		return -ENOBUFS;
+
+	while (nb_rules) {
+
+		if (nb_rules > MAX_BATCH)
+			bulk_sz = MAX_BATCH;
+		else
+			bulk_sz = nb_rules;
+
+
+		ret = rte_mempool_get_bulk(dst_ctx->rule_pool, (void **)rules,
+					   bulk_sz);
+		if (ret < 0) {
+			if (ret == -ENOBUFS)
+				goto error;
+
+			RTE_LOG(ERR, ACL,
+				"Could not allocate memory for destination ctx %s : %s\n",
+				dst_ctx->name, rte_strerror(-ret));
+			goto error;
+		}
+
+		while (bulk_sz-- > 0 && rte_hash_iterate(src_ctx->ht,
+							 (void *) &key,
+							 (void **) &src_rule,
+							 &iter) >= 0) {
+
+			rule = rules[bulk_sz];
+
+			memcpy(rule, src_rule, src_ctx->rule_sz);
+
+			ret = rte_hash_add_key_data(dst_ctx->ht, rule,
+						    (void *) rule);
+			if (ret < 0) {
+				RTE_LOG(ERR, ACL,
+					"Rule addition failed on ctx %s : %s\n",
+					dst_ctx->name, rte_strerror(-ret));
+				goto error;
+			}
+
+			nb_copied++;
+			nb_rules--;
+			dst_ctx->num_rules++;
+		}
+	}
+	return 0;
+
+error:
+	iter = 0;
+	while (nb_copied-- > 0 && rte_hash_iterate(src_ctx->ht, (void *)&key,
+						   (void **)&rule, &iter) >= 0) {
+		err = rte_hash_del_key(dst_ctx->ht, (const void *)rule);
+		if (err < 0) {
+			RTE_LOG(ERR, ACL,
+				"Rule deletion failed during cleanup on ctx %s : %s\n",
+				dst_ctx->name, rte_strerror(-err));
+			continue;
+		}
+		acl_rule_free(dst_ctx, rule);
+		dst_ctx->num_rules--;
+	}
+	return ret;
+}
+
+
+int
+rte_acl_copy_rules(struct rte_acl_ctx *dst_ctx,
+		   const struct rte_acl_ctx *src_ctx)
+{
+	const struct rte_acl_rule *rules;
+	const struct rte_acl_rule *rv;
+	uint32_t i;
+	int32_t rc;
+
+	if (dst_ctx == NULL || src_ctx == NULL || 0 == dst_ctx->rule_sz ||
+	    0 == src_ctx->rule_sz)
+		return -EINVAL;
+
+	if (dst_ctx->flags != src_ctx->flags) {
+		RTE_LOG(ERR, ACL,
+			"Copying only supported between ACLs with same flags\n");
+		return -EINVAL;
+	}
+
+	if (dst_ctx->ht)
+		return acl_copy_rules_ht(dst_ctx, src_ctx);
+
+	return acl_add_rules(dst_ctx, src_ctx->rules, src_ctx->num_rules);
+}
+
 /*
  * Reset all rules.
  * Note that RT structures are not affected.
--- a/lib/librte_acl/version.map
+++ b/lib/librte_acl/version.map
@@ -6,6 +6,7 @@ DPDK_21 {
 	rte_acl_classify;
 	rte_acl_classify_alg;
 	rte_acl_classify_scalar;
+	rte_acl_copy_rules;
 	rte_acl_create;
 	rte_acl_del_rule;
 	rte_acl_dump;
