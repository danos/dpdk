From f67d7c848e2d9124197326cbed5616ac11f1a705 Mon Sep 17 00:00:00 2001
From: Bing Zhao <bingz@nvidia.com>
Date: Sat, 24 Jul 2021 16:27:11 +0300
Subject: [PATCH 27/34] net/mlx5: fix queue leaking in hairpin auto bind check

[ upstream commit 75f166c20ffca1dd28184f8196fbfe90ebafb6ac ]

During the start up stage, the hairpin auto bind was executed for
each port. All the Tx and Rx queues configured for this port should
be checked to confirm if the auto bind of hairpin is needed.
1. The queue is hairpin queue.
2. The peer port is the same one and the peer queue should also be
   with hairpin type.
3. The manual bind attribute is not set for this queue.

If the queue is not a hairpin queue or it doesn't need to be bound
automatically, the reference count should be decreased by 1 since
the count was increased when calling the mlx5_*xq_get().
When the peer port is not the same, it means that no auto bind is
supported and the mlx5_*xq_release() was missed in the current
implementation.

By calling the release function before continue, the count is
correct when calling the device close.

Fixes: aa8bea0e3455 ("net/mlx5: add conditional hairpin auto bind")

Signed-off-by: Bing Zhao <bingz@nvidia.com>
Acked-by: Viacheslav Ovsiienko <viacheslavo@nvidia.com>
---
 drivers/net/mlx5/mlx5_trigger.c | 12 +++++-------
 1 file changed, 5 insertions(+), 7 deletions(-)

diff --git a/drivers/net/mlx5/mlx5_trigger.c b/drivers/net/mlx5/mlx5_trigger.c
index 0c267dce06..33a98ee50c 100644
--- a/drivers/net/mlx5/mlx5_trigger.c
+++ b/drivers/net/mlx5/mlx5_trigger.c
@@ -226,12 +226,11 @@ mlx5_hairpin_auto_bind(struct rte_eth_dev *dev)
 		txq_ctrl = mlx5_txq_get(dev, i);
 		if (!txq_ctrl)
 			continue;
-		if (txq_ctrl->type != MLX5_TXQ_TYPE_HAIRPIN) {
+		if (txq_ctrl->type != MLX5_TXQ_TYPE_HAIRPIN ||
+		    txq_ctrl->hairpin_conf.peers[0].port != self_port) {
 			mlx5_txq_release(dev, i);
 			continue;
 		}
-		if (txq_ctrl->hairpin_conf.peers[0].port != self_port)
-			continue;
 		if (txq_ctrl->hairpin_conf.manual_bind) {
 			mlx5_txq_release(dev, i);
 			return 0;
@@ -245,13 +244,12 @@ mlx5_hairpin_auto_bind(struct rte_eth_dev *dev)
 		txq_ctrl = mlx5_txq_get(dev, i);
 		if (!txq_ctrl)
 			continue;
-		if (txq_ctrl->type != MLX5_TXQ_TYPE_HAIRPIN) {
+		/* Skip hairpin queues with other peer ports. */
+		if (txq_ctrl->type != MLX5_TXQ_TYPE_HAIRPIN ||
+		    txq_ctrl->hairpin_conf.peers[0].port != self_port) {
 			mlx5_txq_release(dev, i);
 			continue;
 		}
-		/* Skip hairpin queues with other peer ports. */
-		if (txq_ctrl->hairpin_conf.peers[0].port != self_port)
-			continue;
 		if (!txq_ctrl->obj) {
 			rte_errno = ENOMEM;
 			DRV_LOG(ERR, "port %u no txq object found: %d",
-- 
2.20.1

