--- a/lib/librte_sched/rte_approx.c
+++ b/lib/librte_sched/rte_approx.c
@@ -165,156 +165,3 @@ int rte_approx(double alpha, double d, u
 	/* Perform approximation */
 	return find_best_rational_approximation(alpha_num, d_num, denum, p, q);
 }
-
-/* fraction comparison (64 bit version): compare (a/b) and (c/d) */
-static inline uint64_t
-less_64(uint64_t a, uint64_t b, uint64_t c, uint64_t d)
-{
-	return a*d < b*c;
-}
-
-static inline uint64_t
-less_or_equal_64(uint64_t a, uint64_t b, uint64_t c, uint64_t d)
-{
-	return a*d <= b*c;
-}
-
-/* check whether a/b is a valid approximation (64 bit version) */
-static inline uint64_t
-matches_64(uint64_t a, uint64_t b,
-	uint64_t alpha_num, uint64_t d_num, uint64_t denum)
-{
-	if (less_or_equal_64(a, b, alpha_num - d_num, denum))
-		return 0;
-
-	if (less_64(a, b, alpha_num + d_num, denum))
-		return 1;
-
-	return 0;
-}
-
-static inline void
-find_exact_solution_left_64(uint64_t p_a, uint64_t q_a, uint64_t p_b, uint64_t q_b,
-	uint64_t alpha_num, uint64_t d_num, uint64_t denum, uint64_t *p, uint64_t *q)
-{
-	uint64_t k_num = denum * p_b - (alpha_num + d_num) * q_b;
-	uint64_t k_denum = (alpha_num + d_num) * q_a - denum * p_a;
-	uint64_t k = (k_num / k_denum) + 1;
-
-	*p = p_b + k * p_a;
-	*q = q_b + k * q_a;
-}
-
-static inline void
-find_exact_solution_right_64(uint64_t p_a, uint64_t q_a, uint64_t p_b, uint64_t q_b,
-	uint64_t alpha_num, uint64_t d_num, uint64_t denum, uint64_t *p, uint64_t *q)
-{
-	uint64_t k_num = -denum * p_b + (alpha_num - d_num) * q_b;
-	uint64_t k_denum = -(alpha_num - d_num) * q_a + denum * p_a;
-	uint64_t k = (k_num / k_denum) + 1;
-
-	*p = p_b + k * p_a;
-	*q = q_b + k * q_a;
-}
-
-static int
-find_best_rational_approximation_64(uint64_t alpha_num, uint64_t d_num,
-	uint64_t denum, uint64_t *p, uint64_t *q)
-{
-	uint64_t p_a, q_a, p_b, q_b;
-
-	/* check assumptions on the inputs */
-	if (!((d_num > 0) && (d_num < alpha_num) &&
-		(alpha_num < denum) && (d_num + alpha_num < denum))) {
-		return -1;
-	}
-
-	/* set initial bounds for the search */
-	p_a = 0;
-	q_a = 1;
-	p_b = 1;
-	q_b = 1;
-
-	while (1) {
-		uint64_t new_p_a, new_q_a, new_p_b, new_q_b;
-		uint64_t x_num, x_denum, x;
-		int aa, bb;
-
-		/* compute the number of steps to the left */
-		x_num = denum * p_b - alpha_num * q_b;
-		x_denum = -denum * p_a + alpha_num * q_a;
-		x = (x_num + x_denum - 1) / x_denum; /* x = ceil(x_num / x_denum) */
-
-		/* check whether we have a valid approximation */
-		aa = matches_64(p_b + x * p_a, q_b + x * q_a, alpha_num, d_num, denum);
-		bb = matches_64(p_b + (x-1) * p_a, q_b + (x - 1) * q_a,
-			alpha_num, d_num, denum);
-		if (aa || bb) {
-			find_exact_solution_left_64(p_a, q_a, p_b, q_b,
-				alpha_num, d_num, denum, p, q);
-			return 0;
-		}
-
-		/* update the interval */
-		new_p_a = p_b + (x - 1) * p_a;
-		new_q_a = q_b + (x - 1) * q_a;
-		new_p_b = p_b + x * p_a;
-		new_q_b = q_b + x * q_a;
-
-		p_a = new_p_a;
-		q_a = new_q_a;
-		p_b = new_p_b;
-		q_b = new_q_b;
-
-		/* compute the number of steps to the right */
-		x_num = alpha_num * q_b - denum * p_b;
-		x_denum = -alpha_num * q_a + denum * p_a;
-		x = (x_num + x_denum - 1) / x_denum; /* x = ceil(x_num / x_denum) */
-
-		/* check whether we have a valid approximation */
-		aa = matches_64(p_b + x * p_a, q_b + x * q_a, alpha_num, d_num, denum);
-		bb = matches_64(p_b + (x - 1) * p_a, q_b + (x - 1) * q_a,
-			alpha_num, d_num, denum);
-		if (aa || bb) {
-			find_exact_solution_right_64(p_a, q_a, p_b, q_b,
-				alpha_num, d_num, denum, p, q);
-			return 0;
-		}
-
-		/* update the interval */
-		new_p_a = p_b + (x - 1) * p_a;
-		new_q_a = q_b + (x - 1) * q_a;
-		new_p_b = p_b + x * p_a;
-		new_q_b = q_b + x * q_a;
-
-		p_a = new_p_a;
-		q_a = new_q_a;
-		p_b = new_p_b;
-		q_b = new_q_b;
-	}
-}
-
-int rte_approx_64(double alpha, double d, uint64_t *p, uint64_t *q)
-{
-	uint64_t alpha_num, d_num, denum;
-
-	/* Check input arguments */
-	if (!((0.0 < d) && (d < alpha) && (alpha < 1.0)))
-		return -1;
-
-	if ((p == NULL) || (q == NULL))
-		return -2;
-
-	/* Compute alpha_num, d_num and denum */
-	denum = 1;
-	while (d < 1) {
-		alpha *= 10;
-		d *= 10;
-		denum *= 10;
-	}
-	alpha_num = (uint64_t) alpha;
-	d_num = (uint64_t) d;
-
-	/* Perform approximation */
-	return find_best_rational_approximation_64(alpha_num, d_num, denum, p, q);
-}
--- a/lib/librte_sched/rte_approx.h
+++ b/lib/librte_sched/rte_approx.h
@@ -39,24 +39,6 @@ extern "C" {
  */
 int rte_approx(double alpha, double d, uint32_t *p, uint32_t *q);
 
-/**
- * Find best rational approximation (64 bit version)
- *
- * @param alpha
- *   Rational number to approximate
- * @param d
- *   Precision for the rational approximation
- * @param p
- *   Pointer to pre-allocated space where the numerator of the rational
- *   approximation will be stored when operation is successful
- * @param q
- *   Pointer to pre-allocated space where the denominator of the rational
- *   approximation will be stored when operation is successful
- * @return
- *   0 upon success, error code otherwise
- */
-int rte_approx_64(double alpha, double d, uint64_t *p, uint64_t *q);
-
 #ifdef __cplusplus
 }
 #endif
--- a/lib/librte_sched/rte_sched.c
+++ b/lib/librte_sched/rte_sched.c
@@ -29,7 +29,7 @@
 
 #ifdef RTE_ARCH_X86
 #define SCHED_VECTOR_SSE4
-#elif defined(__ARM_NEON)
+#elif defined(RTE_MACHINE_CPUFLAG_NEON)
 #define SCHED_VECTOR_NEON
 #endif
 
@@ -37,7 +37,6 @@
 
 #define RTE_SCHED_TB_RATE_CONFIG_ERR          (1e-7)
 #define RTE_SCHED_WRR_SHIFT                   3
-#define RTE_SCHED_MAX_QUEUES_PER_TC           RTE_SCHED_BE_QUEUES_PER_PIPE
 #define RTE_SCHED_GRINDER_PCACHE_SIZE         (64 / RTE_SCHED_QUEUES_PER_PIPE)
 #define RTE_SCHED_PIPE_INVALID                UINT32_MAX
 #define RTE_SCHED_BMP_POS_INVALID             UINT32_MAX
@@ -47,39 +46,67 @@
  */
 #define RTE_SCHED_TIME_SHIFT		      8
 
+struct rte_sched_subport {
+	/* Token bucket (TB) */
+	uint64_t tb_time; /* time of last update */
+	uint32_t tb_period;
+	uint32_t tb_credits_per_period;
+	uint32_t tb_size;
+	uint32_t tb_credits;
+
+	/* Traffic classes (TCs) */
+	uint64_t tc_time; /* time of next update */
+	uint32_t tc_credits_per_period[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	uint32_t tc_credits[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	uint32_t tc_period;
+
+	/* TC oversubscription */
+	uint32_t tc_ov_wm;
+	uint32_t tc_ov_wm_min;
+	uint32_t tc_ov_wm_max;
+	uint8_t tc_ov_period_id;
+	uint8_t tc_ov;
+	uint32_t tc_ov_n;
+	double tc_ov_rate;
+
+	/* Statistics */
+	struct rte_sched_subport_stats stats;
+};
+
 struct rte_sched_pipe_profile {
 	/* Token bucket (TB) */
-	uint64_t tb_period;
-	uint64_t tb_credits_per_period;
-	uint64_t tb_size;
+	uint32_t tb_period;
+	uint32_t tb_credits_per_period;
+	uint32_t tb_size;
 
 	/* Pipe traffic classes */
-	uint64_t tc_period;
-	uint64_t tc_credits_per_period[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	uint32_t tc_period;
+	uint32_t tc_credits_per_period[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
 	uint8_t tc_ov_weight;
 
-	/* Pipe best-effort traffic class queues */
-	uint8_t  wrr_cost[RTE_SCHED_BE_QUEUES_PER_PIPE];
+	/* Pipe queues */
+	uint8_t  wrr_cost[RTE_SCHED_QUEUES_PER_PIPE];
 };
 
 struct rte_sched_pipe {
 	/* Token bucket (TB) */
 	uint64_t tb_time; /* time of last update */
-	uint64_t tb_credits;
+	uint32_t tb_credits;
 
 	/* Pipe profile and flags */
 	uint32_t profile;
 
 	/* Traffic classes (TCs) */
 	uint64_t tc_time; /* time of next update */
-	uint64_t tc_credits[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	uint32_t tc_credits[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
 
 	/* Weighted Round Robin (WRR) */
-	uint8_t wrr_tokens[RTE_SCHED_BE_QUEUES_PER_PIPE];
+	uint8_t wrr_tokens[RTE_SCHED_QUEUES_PER_PIPE];
 
 	/* TC oversubscription */
-	uint64_t tc_ov_credits;
+	uint32_t tc_ov_credits;
 	uint8_t tc_ov_period_id;
+	uint8_t reserved[3];
 } __rte_cache_aligned;
 
 struct rte_sched_queue {
@@ -101,14 +128,20 @@ enum grinder_state {
 	e_GRINDER_READ_MBUF
 };
 
-struct rte_sched_subport_profile {
-	/* Token bucket (TB) */
-	uint64_t tb_period;
-	uint64_t tb_credits_per_period;
-	uint64_t tb_size;
-
-	uint64_t tc_credits_per_period[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-	uint64_t tc_period;
+/*
+ * Path through the scheduler hierarchy used by the scheduler enqueue
+ * operation to identify the destination queue for the current
+ * packet. Stored in the field pkt.hash.sched of struct rte_mbuf of
+ * each packet, typically written by the classification stage and read
+ * by scheduler enqueue.
+ */
+struct rte_sched_port_hierarchy {
+	uint16_t queue:2;                /**< Queue ID (0 .. 3) */
+	uint16_t traffic_class:2;        /**< Traffic class ID (0 .. 3)*/
+	uint32_t color:2;                /**< Color */
+	uint16_t unused:10;
+	uint16_t subport;                /**< Subport ID */
+	uint32_t pipe;		         /**< Pipe ID */
 };
 
 struct rte_sched_grinder {
@@ -123,70 +156,51 @@ struct rte_sched_grinder {
 	uint32_t productive;
 	uint32_t pindex;
 	struct rte_sched_subport *subport;
-	struct rte_sched_subport_profile *subport_params;
 	struct rte_sched_pipe *pipe;
 	struct rte_sched_pipe_profile *pipe_params;
 
 	/* TC cache */
-	uint8_t tccache_qmask[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-	uint32_t tccache_qindex[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	uint8_t tccache_qmask[4];
+	uint32_t tccache_qindex[4];
 	uint32_t tccache_w;
 	uint32_t tccache_r;
 
 	/* Current TC */
 	uint32_t tc_index;
-	struct rte_sched_queue *queue[RTE_SCHED_MAX_QUEUES_PER_TC];
-	struct rte_mbuf **qbase[RTE_SCHED_MAX_QUEUES_PER_TC];
-	uint32_t qindex[RTE_SCHED_MAX_QUEUES_PER_TC];
+	struct rte_sched_queue *queue[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	struct rte_mbuf **qbase[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	uint32_t qindex[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
 	uint16_t qsize;
 	uint32_t qmask;
 	uint32_t qpos;
 	struct rte_mbuf *pkt;
 
 	/* WRR */
-	uint16_t wrr_tokens[RTE_SCHED_BE_QUEUES_PER_PIPE];
-	uint16_t wrr_mask[RTE_SCHED_BE_QUEUES_PER_PIPE];
-	uint8_t wrr_cost[RTE_SCHED_BE_QUEUES_PER_PIPE];
+	uint16_t wrr_tokens[RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS];
+	uint16_t wrr_mask[RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS];
+	uint8_t wrr_cost[RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS];
 };
 
-struct rte_sched_subport {
-	/* Token bucket (TB) */
-	uint64_t tb_time; /* time of last update */
-	uint64_t tb_credits;
-
-	/* Traffic classes (TCs) */
-	uint64_t tc_time; /* time of next update */
-	uint64_t tc_credits[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-
-	/* TC oversubscription */
-	uint64_t tc_ov_wm;
-	uint64_t tc_ov_wm_min;
-	uint64_t tc_ov_wm_max;
-	uint8_t tc_ov_period_id;
-	uint8_t tc_ov;
-	uint32_t tc_ov_n;
-	double tc_ov_rate;
-
-	/* Statistics */
-	struct rte_sched_subport_stats stats __rte_cache_aligned;
-
-	/* subport profile */
-	uint32_t profile;
-	/* Subport pipes */
-	uint32_t n_pipes_per_subport_enabled;
-	uint32_t n_pipe_profiles;
-	uint32_t n_max_pipe_profiles;
-
-	/* Pipe best-effort TC rate */
-	uint64_t pipe_tc_be_rate_max;
-
-	/* Pipe queues size */
+struct rte_sched_port {
+	/* User parameters */
+	uint32_t n_subports_per_port;
+	uint32_t n_pipes_per_subport;
+	uint32_t rate;
+	uint32_t mtu;
+	uint32_t frame_overhead;
 	uint16_t qsize[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-
+	uint32_t n_pipe_profiles;
+	uint32_t pipe_tc3_rate_max;
 #ifdef RTE_SCHED_RED
 	struct rte_red_config red_config[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE][RTE_COLORS];
 #endif
 
+	/* Timing */
+	uint64_t time_cpu_cycles;     /* Current CPU time measured in CPU cyles */
+	uint64_t time_cpu_bytes;      /* Current CPU time measured in bytes */
+	uint64_t time;                /* Current NIC TX time measured in bytes */
+	struct rte_reciprocal inv_cycles_per_byte; /* CPU cycles per byte */
+
 	/* Scheduling loop detection */
 	uint32_t pipe_loop;
 	uint32_t pipe_exhaustion;
@@ -198,11 +212,15 @@ struct rte_sched_subport {
 	/* Grinders */
 	struct rte_sched_grinder grinder[RTE_SCHED_PORT_N_GRINDERS];
 	uint32_t busy_grinders;
+	struct rte_mbuf **pkts_out;
+	uint32_t n_pkts_out;
 
 	/* Queue base calculation */
 	uint32_t qsize_add[RTE_SCHED_QUEUES_PER_PIPE];
 	uint32_t qsize_sum;
 
+	/* Large data structures */
+	struct rte_sched_subport *subport;
 	struct rte_sched_pipe *pipe;
 	struct rte_sched_queue *queue;
 	struct rte_sched_queue_extra *queue_extra;
@@ -212,225 +230,91 @@ struct rte_sched_subport {
 	uint8_t memory[0] __rte_cache_aligned;
 } __rte_cache_aligned;
 
-struct rte_sched_port {
-	/* User parameters */
-	uint32_t n_subports_per_port;
-	uint32_t n_pipes_per_subport;
-	uint32_t n_pipes_per_subport_log2;
-	uint16_t pipe_queue[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-	uint8_t pipe_tc[RTE_SCHED_QUEUES_PER_PIPE];
-	uint8_t tc_queue[RTE_SCHED_QUEUES_PER_PIPE];
-	uint32_t n_subport_profiles;
-	uint32_t n_max_subport_profiles;
-	uint64_t rate;
-	uint32_t mtu;
-	uint32_t frame_overhead;
-	int socket;
-
-	/* Timing */
-	uint64_t time_cpu_cycles;     /* Current CPU time measured in CPU cyles */
-	uint64_t time_cpu_bytes;      /* Current CPU time measured in bytes */
-	uint64_t time;                /* Current NIC TX time measured in bytes */
-	struct rte_reciprocal inv_cycles_per_byte; /* CPU cycles per byte */
-	uint64_t cycles_per_byte;
-
-	/* Grinders */
-	struct rte_mbuf **pkts_out;
-	uint32_t n_pkts_out;
-	uint32_t subport_id;
-
-	/* Large data structures */
-	struct rte_sched_subport_profile *subport_profiles;
-	struct rte_sched_subport *subports[0] __rte_cache_aligned;
-} __rte_cache_aligned;
-
-enum rte_sched_subport_array {
-	e_RTE_SCHED_SUBPORT_ARRAY_PIPE = 0,
-	e_RTE_SCHED_SUBPORT_ARRAY_QUEUE,
-	e_RTE_SCHED_SUBPORT_ARRAY_QUEUE_EXTRA,
-	e_RTE_SCHED_SUBPORT_ARRAY_PIPE_PROFILES,
-	e_RTE_SCHED_SUBPORT_ARRAY_BMP_ARRAY,
-	e_RTE_SCHED_SUBPORT_ARRAY_QUEUE_ARRAY,
-	e_RTE_SCHED_SUBPORT_ARRAY_TOTAL,
+enum rte_sched_port_array {
+	e_RTE_SCHED_PORT_ARRAY_SUBPORT = 0,
+	e_RTE_SCHED_PORT_ARRAY_PIPE,
+	e_RTE_SCHED_PORT_ARRAY_QUEUE,
+	e_RTE_SCHED_PORT_ARRAY_QUEUE_EXTRA,
+	e_RTE_SCHED_PORT_ARRAY_PIPE_PROFILES,
+	e_RTE_SCHED_PORT_ARRAY_BMP_ARRAY,
+	e_RTE_SCHED_PORT_ARRAY_QUEUE_ARRAY,
+	e_RTE_SCHED_PORT_ARRAY_TOTAL,
 };
 
-static inline uint32_t
-rte_sched_subport_pipe_queues(struct rte_sched_subport *subport)
-{
-	return RTE_SCHED_QUEUES_PER_PIPE * subport->n_pipes_per_subport_enabled;
-}
+#ifdef RTE_SCHED_COLLECT_STATS
 
-static inline struct rte_mbuf **
-rte_sched_subport_pipe_qbase(struct rte_sched_subport *subport, uint32_t qindex)
+static inline uint32_t
+rte_sched_port_queues_per_subport(struct rte_sched_port *port)
 {
-	uint32_t pindex = qindex >> 4;
-	uint32_t qpos = qindex & (RTE_SCHED_QUEUES_PER_PIPE - 1);
-
-	return (subport->queue_array + pindex *
-		subport->qsize_sum + subport->qsize_add[qpos]);
+	return RTE_SCHED_QUEUES_PER_PIPE * port->n_pipes_per_subport;
 }
 
-static inline uint16_t
-rte_sched_subport_pipe_qsize(struct rte_sched_port *port,
-struct rte_sched_subport *subport, uint32_t qindex)
-{
-	uint32_t tc = port->pipe_tc[qindex & (RTE_SCHED_QUEUES_PER_PIPE - 1)];
-
-	return subport->qsize[tc];
-}
+#endif
 
 static inline uint32_t
 rte_sched_port_queues_per_port(struct rte_sched_port *port)
 {
-	uint32_t n_queues = 0, i;
-
-	for (i = 0; i < port->n_subports_per_port; i++)
-		n_queues += rte_sched_subport_pipe_queues(port->subports[i]);
-
-	return n_queues;
-}
-
-static inline uint16_t
-rte_sched_port_pipe_queue(struct rte_sched_port *port, uint32_t traffic_class)
-{
-	uint16_t pipe_queue = port->pipe_queue[traffic_class];
-
-	return pipe_queue;
+	return RTE_SCHED_QUEUES_PER_PIPE * port->n_pipes_per_subport * port->n_subports_per_port;
 }
 
-static inline uint8_t
-rte_sched_port_pipe_tc(struct rte_sched_port *port, uint32_t qindex)
+static inline struct rte_mbuf **
+rte_sched_port_qbase(struct rte_sched_port *port, uint32_t qindex)
 {
-	uint8_t pipe_tc = port->pipe_tc[qindex & (RTE_SCHED_QUEUES_PER_PIPE - 1)];
+	uint32_t pindex = qindex >> 4;
+	uint32_t qpos = qindex & 0xF;
 
-	return pipe_tc;
+	return (port->queue_array + pindex *
+		port->qsize_sum + port->qsize_add[qpos]);
 }
 
-static inline uint8_t
-rte_sched_port_tc_queue(struct rte_sched_port *port, uint32_t qindex)
+static inline uint16_t
+rte_sched_port_qsize(struct rte_sched_port *port, uint32_t qindex)
 {
-	uint8_t tc_queue = port->tc_queue[qindex & (RTE_SCHED_QUEUES_PER_PIPE - 1)];
+	uint32_t tc = (qindex >> 2) & 0x3;
 
-	return tc_queue;
+	return port->qsize[tc];
 }
 
 static int
 pipe_profile_check(struct rte_sched_pipe_params *params,
-	uint64_t rate, uint16_t *qsize)
+	uint32_t rate)
 {
 	uint32_t i;
 
 	/* Pipe parameters */
-	if (params == NULL) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for parameter params\n", __func__);
-		return -EINVAL;
-	}
+	if (params == NULL)
+		return -10;
 
 	/* TB rate: non-zero, not greater than port rate */
 	if (params->tb_rate == 0 ||
-		params->tb_rate > rate) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for tb rate\n", __func__);
-		return -EINVAL;
-	}
+		params->tb_rate > rate)
+		return -11;
 
 	/* TB size: non-zero */
-	if (params->tb_size == 0) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for tb size\n", __func__);
-		return -EINVAL;
-	}
+	if (params->tb_size == 0)
+		return -12;
 
-	/* TC rate: non-zero if qsize non-zero, less than pipe rate */
+	/* TC rate: non-zero, less than pipe rate */
 	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++) {
-		if ((qsize[i] == 0 && params->tc_rate[i] != 0) ||
-			(qsize[i] != 0 && (params->tc_rate[i] == 0 ||
-			params->tc_rate[i] > params->tb_rate))) {
-			RTE_LOG(ERR, SCHED,
-				"%s: Incorrect value for qsize or tc_rate\n", __func__);
-			return -EINVAL;
-		}
-	}
-
-	if (params->tc_rate[RTE_SCHED_TRAFFIC_CLASS_BE] == 0 ||
-		qsize[RTE_SCHED_TRAFFIC_CLASS_BE] == 0) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for be traffic class rate\n", __func__);
-		return -EINVAL;
+		if (params->tc_rate[i] == 0 ||
+			params->tc_rate[i] > params->tb_rate)
+			return -13;
 	}
 
 	/* TC period: non-zero */
-	if (params->tc_period == 0) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for tc period\n", __func__);
-		return -EINVAL;
-	}
+	if (params->tc_period == 0)
+		return -14;
 
-	/*  Best effort tc oversubscription weight: non-zero */
-	if (params->tc_ov_weight == 0) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for tc ov weight\n", __func__);
-		return -EINVAL;
-	}
+#ifdef RTE_SCHED_SUBPORT_TC_OV
+	/* TC3 oversubscription weight: non-zero */
+	if (params->tc_ov_weight == 0)
+		return -15;
+#endif
 
 	/* Queue WRR weights: non-zero */
-	for (i = 0; i < RTE_SCHED_BE_QUEUES_PER_PIPE; i++) {
-		if (params->wrr_weights[i] == 0) {
-			RTE_LOG(ERR, SCHED,
-				"%s: Incorrect value for wrr weight\n", __func__);
-			return -EINVAL;
-		}
-	}
-
-	return 0;
-}
-
-static int
-subport_profile_check(struct rte_sched_subport_profile_params *params,
-	uint64_t rate)
-{
-	uint32_t i;
-
-	/* Check user parameters */
-	if (params == NULL) {
-		RTE_LOG(ERR, SCHED, "%s: "
-		"Incorrect value for parameter params\n", __func__);
-		return -EINVAL;
-	}
-
-	if (params->tb_rate == 0 || params->tb_rate > rate) {
-		RTE_LOG(ERR, SCHED, "%s: "
-		"Incorrect value for tb rate\n", __func__);
-		return -EINVAL;
-	}
-
-	if (params->tb_size == 0) {
-		RTE_LOG(ERR, SCHED, "%s: "
-		"Incorrect value for tb size\n", __func__);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++) {
-		uint64_t tc_rate = params->tc_rate[i];
-
-		if (tc_rate == 0 || (tc_rate > params->tb_rate)) {
-			RTE_LOG(ERR, SCHED, "%s: "
-			"Incorrect value for tc rate\n", __func__);
-			return -EINVAL;
-		}
-	}
-
-	if (params->tc_rate[RTE_SCHED_TRAFFIC_CLASS_BE] == 0) {
-		RTE_LOG(ERR, SCHED, "%s: "
-		"Incorrect tc rate(best effort)\n", __func__);
-		return -EINVAL;
-	}
-
-	if (params->tc_period == 0) {
-		RTE_LOG(ERR, SCHED, "%s: "
-		"Incorrect value for tc period\n", __func__);
-		return -EINVAL;
+	for (i = 0; i < RTE_SCHED_QUEUES_PER_PIPE; i++) {
+		if (params->wrr_weights[i] == 0)
+			return -16;
 	}
 
 	return 0;
@@ -441,176 +325,180 @@ rte_sched_port_check_params(struct rte_s
 {
 	uint32_t i;
 
-	if (params == NULL) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for parameter params\n", __func__);
-		return -EINVAL;
-	}
+	if (params == NULL)
+		return -1;
 
 	/* socket */
-	if (params->socket < 0) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for socket id\n", __func__);
-		return -EINVAL;
-	}
+	if (params->socket < 0)
+		return -3;
 
 	/* rate */
-	if (params->rate == 0) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for rate\n", __func__);
-		return -EINVAL;
-	}
+	if (params->rate == 0)
+		return -4;
 
 	/* mtu */
-	if (params->mtu == 0) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for mtu\n", __func__);
-		return -EINVAL;
-	}
+	if (params->mtu == 0)
+		return -5;
 
 	/* n_subports_per_port: non-zero, limited to 16 bits, power of 2 */
 	if (params->n_subports_per_port == 0 ||
 	    params->n_subports_per_port > 1u << 16 ||
-	    !rte_is_power_of_2(params->n_subports_per_port)) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for number of subports\n", __func__);
-		return -EINVAL;
-	}
-
-	if (params->subport_profiles == NULL ||
-		params->n_subport_profiles == 0 ||
-		params->n_max_subport_profiles == 0 ||
-		params->n_subport_profiles > params->n_max_subport_profiles) {
-		RTE_LOG(ERR, SCHED,
-		"%s: Incorrect value for subport profiles\n", __func__);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < params->n_subport_profiles; i++) {
-		struct rte_sched_subport_profile_params *p =
-						params->subport_profiles + i;
-		int status;
-
-		status = subport_profile_check(p, params->rate);
-		if (status != 0) {
-			RTE_LOG(ERR, SCHED,
-			"%s: subport profile check failed(%d)\n",
-			__func__, status);
-			return -EINVAL;
-		}
-	}
+	    !rte_is_power_of_2(params->n_subports_per_port))
+		return -6;
 
 	/* n_pipes_per_subport: non-zero, power of 2 */
 	if (params->n_pipes_per_subport == 0 ||
-	    !rte_is_power_of_2(params->n_pipes_per_subport)) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for maximum pipes number\n", __func__);
-		return -EINVAL;
+	    !rte_is_power_of_2(params->n_pipes_per_subport))
+		return -7;
+
+	/* qsize: non-zero, power of 2,
+	 * no bigger than 32K (due to 16-bit read/write pointers)
+	 */
+	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++) {
+		uint16_t qsize = params->qsize[i];
+
+		if (qsize == 0 || !rte_is_power_of_2(qsize))
+			return -8;
+	}
+
+	/* pipe_profiles and n_pipe_profiles */
+	if (params->pipe_profiles == NULL ||
+	    params->n_pipe_profiles == 0 ||
+	    params->n_pipe_profiles > RTE_SCHED_PIPE_PROFILES_PER_PORT)
+		return -9;
+
+	for (i = 0; i < params->n_pipe_profiles; i++) {
+		struct rte_sched_pipe_params *p = params->pipe_profiles + i;
+		int status;
+
+		status = pipe_profile_check(p, params->rate);
+		if (status != 0)
+			return status;
 	}
 
 	return 0;
 }
 
 static uint32_t
-rte_sched_subport_get_array_base(struct rte_sched_subport_params *params,
-	enum rte_sched_subport_array array)
+rte_sched_port_get_array_base(struct rte_sched_port_params *params, enum rte_sched_port_array array)
 {
-	uint32_t n_pipes_per_subport = params->n_pipes_per_subport_enabled;
-	uint32_t n_subport_pipe_queues =
-		RTE_SCHED_QUEUES_PER_PIPE * n_pipes_per_subport;
-
-	uint32_t size_pipe = n_pipes_per_subport * sizeof(struct rte_sched_pipe);
-	uint32_t size_queue =
-		n_subport_pipe_queues * sizeof(struct rte_sched_queue);
+	uint32_t n_subports_per_port = params->n_subports_per_port;
+	uint32_t n_pipes_per_subport = params->n_pipes_per_subport;
+	uint32_t n_pipes_per_port = n_pipes_per_subport * n_subports_per_port;
+	uint32_t n_queues_per_port = RTE_SCHED_QUEUES_PER_PIPE * n_pipes_per_subport * n_subports_per_port;
+
+	uint32_t size_subport = n_subports_per_port * sizeof(struct rte_sched_subport);
+	uint32_t size_pipe = n_pipes_per_port * sizeof(struct rte_sched_pipe);
+	uint32_t size_queue = n_queues_per_port * sizeof(struct rte_sched_queue);
 	uint32_t size_queue_extra
-		= n_subport_pipe_queues * sizeof(struct rte_sched_queue_extra);
-	uint32_t size_pipe_profiles = params->n_max_pipe_profiles *
-		sizeof(struct rte_sched_pipe_profile);
-	uint32_t size_bmp_array =
-		rte_bitmap_get_memory_footprint(n_subport_pipe_queues);
+		= n_queues_per_port * sizeof(struct rte_sched_queue_extra);
+	uint32_t size_pipe_profiles
+		= RTE_SCHED_PIPE_PROFILES_PER_PORT * sizeof(struct rte_sched_pipe_profile);
+	uint32_t size_bmp_array = rte_bitmap_get_memory_footprint(n_queues_per_port);
 	uint32_t size_per_pipe_queue_array, size_queue_array;
 
 	uint32_t base, i;
 
 	size_per_pipe_queue_array = 0;
 	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++) {
-		if (i < RTE_SCHED_TRAFFIC_CLASS_BE)
-			size_per_pipe_queue_array +=
-				params->qsize[i] * sizeof(struct rte_mbuf *);
-		else
-			size_per_pipe_queue_array += RTE_SCHED_MAX_QUEUES_PER_TC *
-				params->qsize[i] * sizeof(struct rte_mbuf *);
+		size_per_pipe_queue_array += RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS
+			* params->qsize[i] * sizeof(struct rte_mbuf *);
 	}
-	size_queue_array = n_pipes_per_subport * size_per_pipe_queue_array;
+	size_queue_array = n_pipes_per_port * size_per_pipe_queue_array;
 
 	base = 0;
 
-	if (array == e_RTE_SCHED_SUBPORT_ARRAY_PIPE)
+	if (array == e_RTE_SCHED_PORT_ARRAY_SUBPORT)
+		return base;
+	base += RTE_CACHE_LINE_ROUNDUP(size_subport);
+
+	if (array == e_RTE_SCHED_PORT_ARRAY_PIPE)
 		return base;
 	base += RTE_CACHE_LINE_ROUNDUP(size_pipe);
 
-	if (array == e_RTE_SCHED_SUBPORT_ARRAY_QUEUE)
+	if (array == e_RTE_SCHED_PORT_ARRAY_QUEUE)
 		return base;
 	base += RTE_CACHE_LINE_ROUNDUP(size_queue);
 
-	if (array == e_RTE_SCHED_SUBPORT_ARRAY_QUEUE_EXTRA)
+	if (array == e_RTE_SCHED_PORT_ARRAY_QUEUE_EXTRA)
 		return base;
 	base += RTE_CACHE_LINE_ROUNDUP(size_queue_extra);
 
-	if (array == e_RTE_SCHED_SUBPORT_ARRAY_PIPE_PROFILES)
+	if (array == e_RTE_SCHED_PORT_ARRAY_PIPE_PROFILES)
 		return base;
 	base += RTE_CACHE_LINE_ROUNDUP(size_pipe_profiles);
 
-	if (array == e_RTE_SCHED_SUBPORT_ARRAY_BMP_ARRAY)
+	if (array == e_RTE_SCHED_PORT_ARRAY_BMP_ARRAY)
 		return base;
 	base += RTE_CACHE_LINE_ROUNDUP(size_bmp_array);
 
-	if (array == e_RTE_SCHED_SUBPORT_ARRAY_QUEUE_ARRAY)
+	if (array == e_RTE_SCHED_PORT_ARRAY_QUEUE_ARRAY)
 		return base;
 	base += RTE_CACHE_LINE_ROUNDUP(size_queue_array);
 
 	return base;
 }
 
-static void
-rte_sched_subport_config_qsize(struct rte_sched_subport *subport)
+uint32_t
+rte_sched_port_get_memory_footprint(struct rte_sched_port_params *params)
 {
-	uint32_t i;
+	uint32_t size0, size1;
+	int status;
 
-	subport->qsize_add[0] = 0;
+	status = rte_sched_port_check_params(params);
+	if (status != 0) {
+		RTE_LOG(NOTICE, SCHED,
+			"Port scheduler params check failed (%d)\n", status);
 
-	/* Strict prority traffic class */
-	for (i = 1; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++)
-		subport->qsize_add[i] = subport->qsize_add[i-1] + subport->qsize[i-1];
-
-	/* Best-effort traffic class */
-	subport->qsize_add[RTE_SCHED_TRAFFIC_CLASS_BE + 1] =
-		subport->qsize_add[RTE_SCHED_TRAFFIC_CLASS_BE] +
-		subport->qsize[RTE_SCHED_TRAFFIC_CLASS_BE];
-	subport->qsize_add[RTE_SCHED_TRAFFIC_CLASS_BE + 2] =
-		subport->qsize_add[RTE_SCHED_TRAFFIC_CLASS_BE + 1] +
-		subport->qsize[RTE_SCHED_TRAFFIC_CLASS_BE];
-	subport->qsize_add[RTE_SCHED_TRAFFIC_CLASS_BE + 3] =
-		subport->qsize_add[RTE_SCHED_TRAFFIC_CLASS_BE + 2] +
-		subport->qsize[RTE_SCHED_TRAFFIC_CLASS_BE];
+		return 0;
+	}
+
+	size0 = sizeof(struct rte_sched_port);
+	size1 = rte_sched_port_get_array_base(params, e_RTE_SCHED_PORT_ARRAY_TOTAL);
+
+	return size0 + size1;
+}
+
+static void
+rte_sched_port_config_qsize(struct rte_sched_port *port)
+{
+	/* TC 0 */
+	port->qsize_add[0] = 0;
+	port->qsize_add[1] = port->qsize_add[0] + port->qsize[0];
+	port->qsize_add[2] = port->qsize_add[1] + port->qsize[0];
+	port->qsize_add[3] = port->qsize_add[2] + port->qsize[0];
+
+	/* TC 1 */
+	port->qsize_add[4] = port->qsize_add[3] + port->qsize[0];
+	port->qsize_add[5] = port->qsize_add[4] + port->qsize[1];
+	port->qsize_add[6] = port->qsize_add[5] + port->qsize[1];
+	port->qsize_add[7] = port->qsize_add[6] + port->qsize[1];
+
+	/* TC 2 */
+	port->qsize_add[8] = port->qsize_add[7] + port->qsize[1];
+	port->qsize_add[9] = port->qsize_add[8] + port->qsize[2];
+	port->qsize_add[10] = port->qsize_add[9] + port->qsize[2];
+	port->qsize_add[11] = port->qsize_add[10] + port->qsize[2];
+
+	/* TC 3 */
+	port->qsize_add[12] = port->qsize_add[11] + port->qsize[2];
+	port->qsize_add[13] = port->qsize_add[12] + port->qsize[3];
+	port->qsize_add[14] = port->qsize_add[13] + port->qsize[3];
+	port->qsize_add[15] = port->qsize_add[14] + port->qsize[3];
 
-	subport->qsize_sum = subport->qsize_add[RTE_SCHED_TRAFFIC_CLASS_BE + 3] +
-		subport->qsize[RTE_SCHED_TRAFFIC_CLASS_BE];
+	port->qsize_sum = port->qsize_add[15] + port->qsize[3];
 }
 
 static void
-rte_sched_port_log_pipe_profile(struct rte_sched_subport *subport, uint32_t i)
+rte_sched_port_log_pipe_profile(struct rte_sched_port *port, uint32_t i)
 {
-	struct rte_sched_pipe_profile *p = subport->pipe_profiles + i;
+	struct rte_sched_pipe_profile *p = port->pipe_profiles + i;
 
 	RTE_LOG(DEBUG, SCHED, "Low level config for pipe profile %u:\n"
-		"	Token bucket: period = %"PRIu64", credits per period = %"PRIu64", size = %"PRIu64"\n"
-		"	Traffic classes: period = %"PRIu64",\n"
-		"	credits per period = [%"PRIu64", %"PRIu64", %"PRIu64", %"PRIu64
-		", %"PRIu64", %"PRIu64", %"PRIu64", %"PRIu64", %"PRIu64", %"PRIu64
-		", %"PRIu64", %"PRIu64", %"PRIu64"]\n"
-		"	Best-effort traffic class oversubscription: weight = %hhu\n"
-		"	WRR cost: [%hhu, %hhu, %hhu, %hhu]\n",
+		"    Token bucket: period = %u, credits per period = %u, size = %u\n"
+		"    Traffic classes: period = %u, credits per period = [%u, %u, %u, %u]\n"
+		"    Traffic class 3 oversubscription: weight = %hhu\n"
+		"    WRR cost: [%hhu, %hhu, %hhu, %hhu], [%hhu, %hhu, %hhu, %hhu], [%hhu, %hhu, %hhu, %hhu], [%hhu, %hhu, %hhu, %hhu]\n",
 		i,
 
 		/* Token bucket */
@@ -624,61 +512,19 @@ rte_sched_port_log_pipe_profile(struct r
 		p->tc_credits_per_period[1],
 		p->tc_credits_per_period[2],
 		p->tc_credits_per_period[3],
-		p->tc_credits_per_period[4],
-		p->tc_credits_per_period[5],
-		p->tc_credits_per_period[6],
-		p->tc_credits_per_period[7],
-		p->tc_credits_per_period[8],
-		p->tc_credits_per_period[9],
-		p->tc_credits_per_period[10],
-		p->tc_credits_per_period[11],
-		p->tc_credits_per_period[12],
 
-		/* Best-effort traffic class oversubscription */
+		/* Traffic class 3 oversubscription */
 		p->tc_ov_weight,
 
 		/* WRR */
-		p->wrr_cost[0], p->wrr_cost[1], p->wrr_cost[2], p->wrr_cost[3]);
-}
-
-static void
-rte_sched_port_log_subport_profile(struct rte_sched_port *port, uint32_t i)
-{
-	struct rte_sched_subport_profile *p = port->subport_profiles + i;
-
-	RTE_LOG(DEBUG, SCHED, "Low level config for subport profile %u:\n"
-	"Token bucket: period = %"PRIu64", credits per period = %"PRIu64","
-	"size = %"PRIu64"\n"
-	"Traffic classes: period = %"PRIu64",\n"
-	"credits per period = [%"PRIu64", %"PRIu64", %"PRIu64", %"PRIu64
-	" %"PRIu64", %"PRIu64", %"PRIu64", %"PRIu64", %"PRIu64", %"PRIu64
-	" %"PRIu64", %"PRIu64", %"PRIu64"]\n",
-	i,
-
-	/* Token bucket */
-	p->tb_period,
-	p->tb_credits_per_period,
-	p->tb_size,
-
-	/* Traffic classes */
-	p->tc_period,
-	p->tc_credits_per_period[0],
-	p->tc_credits_per_period[1],
-	p->tc_credits_per_period[2],
-	p->tc_credits_per_period[3],
-	p->tc_credits_per_period[4],
-	p->tc_credits_per_period[5],
-	p->tc_credits_per_period[6],
-	p->tc_credits_per_period[7],
-	p->tc_credits_per_period[8],
-	p->tc_credits_per_period[9],
-	p->tc_credits_per_period[10],
-	p->tc_credits_per_period[11],
-	p->tc_credits_per_period[12]);
+		p->wrr_cost[ 0], p->wrr_cost[ 1], p->wrr_cost[ 2], p->wrr_cost[ 3],
+		p->wrr_cost[ 4], p->wrr_cost[ 5], p->wrr_cost[ 6], p->wrr_cost[ 7],
+		p->wrr_cost[ 8], p->wrr_cost[ 9], p->wrr_cost[10], p->wrr_cost[11],
+		p->wrr_cost[12], p->wrr_cost[13], p->wrr_cost[14], p->wrr_cost[15]);
 }
 
 static inline uint64_t
-rte_sched_time_ms_to_bytes(uint64_t time_ms, uint64_t rate)
+rte_sched_time_ms_to_bytes(uint32_t time_ms, uint32_t rate)
 {
 	uint64_t time = time_ms;
 
@@ -688,13 +534,10 @@ rte_sched_time_ms_to_bytes(uint64_t time
 }
 
 static void
-rte_sched_pipe_profile_convert(struct rte_sched_subport *subport,
-	struct rte_sched_pipe_params *src,
+rte_sched_pipe_profile_convert(struct rte_sched_pipe_params *src,
 	struct rte_sched_pipe_profile *dst,
-	uint64_t rate)
+	uint32_t rate)
 {
-	uint32_t wrr_cost[RTE_SCHED_BE_QUEUES_PER_PIPE];
-	uint32_t lcd1, lcd2, lcd;
 	uint32_t i;
 
 	/* Token Bucket */
@@ -706,8 +549,8 @@ rte_sched_pipe_profile_convert(struct rt
 				/ (double) rate;
 		double d = RTE_SCHED_TB_RATE_CONFIG_ERR;
 
-		rte_approx_64(tb_rate, d, &dst->tb_credits_per_period,
-			&dst->tb_period);
+		rte_approx(tb_rate, d,
+			&dst->tb_credits_per_period, &dst->tb_period);
 	}
 
 	dst->tb_size = src->tb_size;
@@ -717,572 +560,310 @@ rte_sched_pipe_profile_convert(struct rt
 						rate);
 
 	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++)
-		if (subport->qsize[i])
-			dst->tc_credits_per_period[i]
-				= rte_sched_time_ms_to_bytes(src->tc_period,
-					src->tc_rate[i]);
-
-	dst->tc_ov_weight = src->tc_ov_weight;
-
-	/* WRR queues */
-	wrr_cost[0] = src->wrr_weights[0];
-	wrr_cost[1] = src->wrr_weights[1];
-	wrr_cost[2] = src->wrr_weights[2];
-	wrr_cost[3] = src->wrr_weights[3];
-
-	lcd1 = rte_get_lcd(wrr_cost[0], wrr_cost[1]);
-	lcd2 = rte_get_lcd(wrr_cost[2], wrr_cost[3]);
-	lcd = rte_get_lcd(lcd1, lcd2);
-
-	wrr_cost[0] = lcd / wrr_cost[0];
-	wrr_cost[1] = lcd / wrr_cost[1];
-	wrr_cost[2] = lcd / wrr_cost[2];
-	wrr_cost[3] = lcd / wrr_cost[3];
-
-	dst->wrr_cost[0] = (uint8_t) wrr_cost[0];
-	dst->wrr_cost[1] = (uint8_t) wrr_cost[1];
-	dst->wrr_cost[2] = (uint8_t) wrr_cost[2];
-	dst->wrr_cost[3] = (uint8_t) wrr_cost[3];
-}
-
-static void
-rte_sched_subport_profile_convert(struct rte_sched_subport_profile_params *src,
-	struct rte_sched_subport_profile *dst,
-	uint64_t rate)
-{
-	uint32_t i;
-
-	/* Token Bucket */
-	if (src->tb_rate == rate) {
-		dst->tb_credits_per_period = 1;
-		dst->tb_period = 1;
-	} else {
-		double tb_rate = (double) src->tb_rate
-				/ (double) rate;
-		double d = RTE_SCHED_TB_RATE_CONFIG_ERR;
-
-		rte_approx_64(tb_rate, d, &dst->tb_credits_per_period,
-			&dst->tb_period);
-	}
-
-	dst->tb_size = src->tb_size;
-
-	/* Traffic Classes */
-	dst->tc_period = rte_sched_time_ms_to_bytes(src->tc_period, rate);
-
-	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++)
 		dst->tc_credits_per_period[i]
 			= rte_sched_time_ms_to_bytes(src->tc_period,
 				src->tc_rate[i]);
-}
 
-static void
-rte_sched_subport_config_pipe_profile_table(struct rte_sched_subport *subport,
-	struct rte_sched_subport_params *params, uint64_t rate)
-{
-	uint32_t i;
-
-	for (i = 0; i < subport->n_pipe_profiles; i++) {
-		struct rte_sched_pipe_params *src = params->pipe_profiles + i;
-		struct rte_sched_pipe_profile *dst = subport->pipe_profiles + i;
-
-		rte_sched_pipe_profile_convert(subport, src, dst, rate);
-		rte_sched_port_log_pipe_profile(subport, i);
-	}
-
-	subport->pipe_tc_be_rate_max = 0;
-	for (i = 0; i < subport->n_pipe_profiles; i++) {
-		struct rte_sched_pipe_params *src = params->pipe_profiles + i;
-		uint64_t pipe_tc_be_rate = src->tc_rate[RTE_SCHED_TRAFFIC_CLASS_BE];
+#ifdef RTE_SCHED_SUBPORT_TC_OV
+	dst->tc_ov_weight = src->tc_ov_weight;
+#endif
 
-		if (subport->pipe_tc_be_rate_max < pipe_tc_be_rate)
-			subport->pipe_tc_be_rate_max = pipe_tc_be_rate;
+	/* WRR */
+	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++) {
+		uint32_t wrr_cost[RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS];
+		uint32_t lcd, lcd1, lcd2;
+		uint32_t qindex;
+
+		qindex = i * RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS;
+
+		wrr_cost[0] = src->wrr_weights[qindex];
+		wrr_cost[1] = src->wrr_weights[qindex + 1];
+		wrr_cost[2] = src->wrr_weights[qindex + 2];
+		wrr_cost[3] = src->wrr_weights[qindex + 3];
+
+		lcd1 = rte_get_lcd(wrr_cost[0], wrr_cost[1]);
+		lcd2 = rte_get_lcd(wrr_cost[2], wrr_cost[3]);
+		lcd = rte_get_lcd(lcd1, lcd2);
+
+		wrr_cost[0] = lcd / wrr_cost[0];
+		wrr_cost[1] = lcd / wrr_cost[1];
+		wrr_cost[2] = lcd / wrr_cost[2];
+		wrr_cost[3] = lcd / wrr_cost[3];
+
+		dst->wrr_cost[qindex] = (uint8_t) wrr_cost[0];
+		dst->wrr_cost[qindex + 1] = (uint8_t) wrr_cost[1];
+		dst->wrr_cost[qindex + 2] = (uint8_t) wrr_cost[2];
+		dst->wrr_cost[qindex + 3] = (uint8_t) wrr_cost[3];
 	}
 }
 
 static void
-rte_sched_port_config_subport_profile_table(struct rte_sched_port *port,
-	struct rte_sched_port_params *params,
-	uint64_t rate)
-{
-	uint32_t i;
-
-	for (i = 0; i < port->n_subport_profiles; i++) {
-		struct rte_sched_subport_profile_params *src
-				= params->subport_profiles + i;
-		struct rte_sched_subport_profile *dst
-				= port->subport_profiles + i;
-
-		rte_sched_subport_profile_convert(src, dst, rate);
-		rte_sched_port_log_subport_profile(port, i);
-	}
-}
-
-static int
-rte_sched_subport_check_params(struct rte_sched_subport_params *params,
-	uint32_t n_max_pipes_per_subport,
-	uint64_t rate)
+rte_sched_port_config_pipe_profile_table(struct rte_sched_port *port,
+	struct rte_sched_port_params *params)
 {
 	uint32_t i;
 
-	/* Check user parameters */
-	if (params == NULL) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for parameter params\n", __func__);
-		return -EINVAL;
-	}
-
-	/* qsize: if non-zero, power of 2,
-	 * no bigger than 32K (due to 16-bit read/write pointers)
-	 */
-	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++) {
-		uint16_t qsize = params->qsize[i];
-
-		if (qsize != 0 && !rte_is_power_of_2(qsize)) {
-			RTE_LOG(ERR, SCHED,
-				"%s: Incorrect value for qsize\n", __func__);
-			return -EINVAL;
-		}
-	}
-
-	if (params->qsize[RTE_SCHED_TRAFFIC_CLASS_BE] == 0) {
-		RTE_LOG(ERR, SCHED, "%s: Incorrect qsize\n", __func__);
-		return -EINVAL;
-	}
-
-	/* n_pipes_per_subport: non-zero, power of 2 */
-	if (params->n_pipes_per_subport_enabled == 0 ||
-		params->n_pipes_per_subport_enabled > n_max_pipes_per_subport ||
-	    !rte_is_power_of_2(params->n_pipes_per_subport_enabled)) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for pipes number\n", __func__);
-		return -EINVAL;
-	}
-
-	/* pipe_profiles and n_pipe_profiles */
-	if (params->pipe_profiles == NULL ||
-	    params->n_pipe_profiles == 0 ||
-		params->n_max_pipe_profiles == 0 ||
-		params->n_pipe_profiles > params->n_max_pipe_profiles) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for pipe profiles\n", __func__);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < params->n_pipe_profiles; i++) {
-		struct rte_sched_pipe_params *p = params->pipe_profiles + i;
-		int status;
-
-		status = pipe_profile_check(p, rate, &params->qsize[0]);
-		if (status != 0) {
-			RTE_LOG(ERR, SCHED,
-				"%s: Pipe profile check failed(%d)\n", __func__, status);
-			return -EINVAL;
-		}
-	}
-
-	return 0;
-}
-
-uint32_t
-rte_sched_port_get_memory_footprint(struct rte_sched_port_params *port_params,
-	struct rte_sched_subport_params **subport_params)
-{
-	uint32_t size0 = 0, size1 = 0, i;
-	int status;
-
-	status = rte_sched_port_check_params(port_params);
-	if (status != 0) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Port scheduler port params check failed (%d)\n",
-			__func__, status);
-
-		return 0;
-	}
-
-	for (i = 0; i < port_params->n_subports_per_port; i++) {
-		struct rte_sched_subport_params *sp = subport_params[i];
-
-		status = rte_sched_subport_check_params(sp,
-				port_params->n_pipes_per_subport,
-				port_params->rate);
-		if (status != 0) {
-			RTE_LOG(ERR, SCHED,
-				"%s: Port scheduler subport params check failed (%d)\n",
-				__func__, status);
+	for (i = 0; i < port->n_pipe_profiles; i++) {
+		struct rte_sched_pipe_params *src = params->pipe_profiles + i;
+		struct rte_sched_pipe_profile *dst = port->pipe_profiles + i;
 
-			return 0;
-		}
+		rte_sched_pipe_profile_convert(src, dst, params->rate);
+		rte_sched_port_log_pipe_profile(port, i);
 	}
 
-	size0 = sizeof(struct rte_sched_port);
-
-	for (i = 0; i < port_params->n_subports_per_port; i++) {
-		struct rte_sched_subport_params *sp = subport_params[i];
+	port->pipe_tc3_rate_max = 0;
+	for (i = 0; i < port->n_pipe_profiles; i++) {
+		struct rte_sched_pipe_params *src = params->pipe_profiles + i;
+		uint32_t pipe_tc3_rate = src->tc_rate[3];
 
-		size1 += rte_sched_subport_get_array_base(sp,
-					e_RTE_SCHED_SUBPORT_ARRAY_TOTAL);
+		if (port->pipe_tc3_rate_max < pipe_tc3_rate)
+			port->pipe_tc3_rate_max = pipe_tc3_rate;
 	}
-
-	return size0 + size1;
 }
 
 struct rte_sched_port *
 rte_sched_port_config(struct rte_sched_port_params *params)
 {
 	struct rte_sched_port *port = NULL;
-	uint32_t size0, size1, size2;
-	uint32_t cycles_per_byte;
-	uint32_t i, j;
-	int status;
+	uint32_t mem_size, bmp_mem_size, n_queues_per_port, i, cycles_per_byte;
 
-	status = rte_sched_port_check_params(params);
-	if (status != 0) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Port scheduler params check failed (%d)\n",
-			__func__, status);
+	/* Check user parameters. Determine the amount of memory to allocate */
+	mem_size = rte_sched_port_get_memory_footprint(params);
+	if (mem_size == 0)
 		return NULL;
-	}
-
-	size0 = sizeof(struct rte_sched_port);
-	size1 = params->n_subports_per_port * sizeof(struct rte_sched_subport *);
-	size2 = params->n_max_subport_profiles *
-		sizeof(struct rte_sched_subport_profile);
 
 	/* Allocate memory to store the data structures */
-	port = rte_zmalloc_socket("qos_params", size0 + size1,
-				 RTE_CACHE_LINE_SIZE, params->socket);
-	if (port == NULL) {
-		RTE_LOG(ERR, SCHED, "%s: Memory allocation fails\n", __func__);
-
+	port = rte_zmalloc_socket("qos_params", mem_size, RTE_CACHE_LINE_SIZE,
+		params->socket);
+	if (port == NULL)
 		return NULL;
-	}
 
-	/* Allocate memory to store the subport profile */
-	port->subport_profiles  = rte_zmalloc_socket("subport_profile", size2,
-					RTE_CACHE_LINE_SIZE, params->socket);
-	if (port == NULL) {
-		RTE_LOG(ERR, SCHED, "%s: Memory allocation fails\n", __func__);
-
-		return NULL;
-	}
+	/* compile time checks */
+	RTE_BUILD_BUG_ON(RTE_SCHED_PORT_N_GRINDERS == 0);
+	RTE_BUILD_BUG_ON(RTE_SCHED_PORT_N_GRINDERS & (RTE_SCHED_PORT_N_GRINDERS - 1));
 
 	/* User parameters */
 	port->n_subports_per_port = params->n_subports_per_port;
-	port->n_subport_profiles = params->n_subport_profiles;
-	port->n_max_subport_profiles = params->n_max_subport_profiles;
 	port->n_pipes_per_subport = params->n_pipes_per_subport;
-	port->n_pipes_per_subport_log2 =
-			__builtin_ctz(params->n_pipes_per_subport);
-	port->socket = params->socket;
-
-	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++)
-		port->pipe_queue[i] = i;
-
-	for (i = 0, j = 0; i < RTE_SCHED_QUEUES_PER_PIPE; i++) {
-		port->pipe_tc[i] = j;
+	port->rate = params->rate;
+	port->mtu = params->mtu + params->frame_overhead;
+	port->frame_overhead = params->frame_overhead;
+	memcpy(port->qsize, params->qsize, sizeof(params->qsize));
+	port->n_pipe_profiles = params->n_pipe_profiles;
 
-		if (j < RTE_SCHED_TRAFFIC_CLASS_BE)
-			j++;
-	}
+#ifdef RTE_SCHED_RED
+	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++) {
+		uint32_t j;
 
-	for (i = 0, j = 0; i < RTE_SCHED_QUEUES_PER_PIPE; i++) {
-		port->tc_queue[i] = j;
+		for (j = 0; j < RTE_COLORS; j++) {
+			/* if min/max are both zero, then RED is disabled */
+			if ((params->red_params[i][j].min_th |
+			     params->red_params[i][j].max_th) == 0) {
+				continue;
+			}
 
-		if (i >= RTE_SCHED_TRAFFIC_CLASS_BE)
-			j++;
+			if (rte_red_config_init(&port->red_config[i][j],
+				params->red_params[i][j].wq_log2,
+				params->red_params[i][j].min_th,
+				params->red_params[i][j].max_th,
+				params->red_params[i][j].maxp_inv) != 0) {
+				rte_free(port);
+				return NULL;
+			}
+		}
 	}
-	port->rate = params->rate;
-	port->mtu = params->mtu + params->frame_overhead;
-	port->frame_overhead = params->frame_overhead;
+#endif
 
 	/* Timing */
 	port->time_cpu_cycles = rte_get_tsc_cycles();
 	port->time_cpu_bytes = 0;
 	port->time = 0;
 
-	/* Subport profile table */
-	rte_sched_port_config_subport_profile_table(port, params, port->rate);
-
 	cycles_per_byte = (rte_get_tsc_hz() << RTE_SCHED_TIME_SHIFT)
 		/ params->rate;
 	port->inv_cycles_per_byte = rte_reciprocal_value(cycles_per_byte);
-	port->cycles_per_byte = cycles_per_byte;
+
+	/* Scheduling loop detection */
+	port->pipe_loop = RTE_SCHED_PIPE_INVALID;
+	port->pipe_exhaustion = 0;
 
 	/* Grinders */
+	port->busy_grinders = 0;
 	port->pkts_out = NULL;
 	port->n_pkts_out = 0;
-	port->subport_id = 0;
 
-	return port;
-}
+	/* Queue base calculation */
+	rte_sched_port_config_qsize(port);
 
-static inline void
-rte_sched_subport_free(struct rte_sched_port *port,
-	struct rte_sched_subport *subport)
-{
-	uint32_t n_subport_pipe_queues;
-	uint32_t qindex;
+	/* Large data structures */
+	port->subport = (struct rte_sched_subport *)
+		(port->memory + rte_sched_port_get_array_base(params,
+							      e_RTE_SCHED_PORT_ARRAY_SUBPORT));
+	port->pipe = (struct rte_sched_pipe *)
+		(port->memory + rte_sched_port_get_array_base(params,
+							      e_RTE_SCHED_PORT_ARRAY_PIPE));
+	port->queue = (struct rte_sched_queue *)
+		(port->memory + rte_sched_port_get_array_base(params,
+							      e_RTE_SCHED_PORT_ARRAY_QUEUE));
+	port->queue_extra = (struct rte_sched_queue_extra *)
+		(port->memory + rte_sched_port_get_array_base(params,
+							      e_RTE_SCHED_PORT_ARRAY_QUEUE_EXTRA));
+	port->pipe_profiles = (struct rte_sched_pipe_profile *)
+		(port->memory + rte_sched_port_get_array_base(params,
+							      e_RTE_SCHED_PORT_ARRAY_PIPE_PROFILES));
+	port->bmp_array =  port->memory
+		+ rte_sched_port_get_array_base(params, e_RTE_SCHED_PORT_ARRAY_BMP_ARRAY);
+	port->queue_array = (struct rte_mbuf **)
+		(port->memory + rte_sched_port_get_array_base(params,
+							      e_RTE_SCHED_PORT_ARRAY_QUEUE_ARRAY));
 
-	if (subport == NULL)
-		return;
+	/* Pipe profile table */
+	rte_sched_port_config_pipe_profile_table(port, params);
 
-	n_subport_pipe_queues = rte_sched_subport_pipe_queues(subport);
+	/* Bitmap */
+	n_queues_per_port = rte_sched_port_queues_per_port(port);
+	bmp_mem_size = rte_bitmap_get_memory_footprint(n_queues_per_port);
+	port->bmp = rte_bitmap_init(n_queues_per_port, port->bmp_array,
+				    bmp_mem_size);
+	if (port->bmp == NULL) {
+		RTE_LOG(ERR, SCHED, "Bitmap init error\n");
+		rte_free(port);
+		return NULL;
+	}
 
-	/* Free enqueued mbufs */
-	for (qindex = 0; qindex < n_subport_pipe_queues; qindex++) {
-		struct rte_mbuf **mbufs =
-			rte_sched_subport_pipe_qbase(subport, qindex);
-		uint16_t qsize = rte_sched_subport_pipe_qsize(port, subport, qindex);
-		if (qsize != 0) {
-			struct rte_sched_queue *queue = subport->queue + qindex;
-			uint16_t qr = queue->qr & (qsize - 1);
-			uint16_t qw = queue->qw & (qsize - 1);
+	for (i = 0; i < RTE_SCHED_PORT_N_GRINDERS; i++)
+		port->grinder_base_bmp_pos[i] = RTE_SCHED_PIPE_INVALID;
 
-			for (; qr != qw; qr = (qr + 1) & (qsize - 1))
-				rte_pktmbuf_free(mbufs[qr]);
-		}
-	}
 
-	rte_free(subport);
+	return port;
 }
 
 void
 rte_sched_port_free(struct rte_sched_port *port)
 {
-	uint32_t i;
+	uint32_t qindex;
+	uint32_t n_queues_per_port;
 
 	/* Check user parameters */
 	if (port == NULL)
 		return;
 
-	for (i = 0; i < port->n_subports_per_port; i++)
-		rte_sched_subport_free(port, port->subports[i]);
+	n_queues_per_port = rte_sched_port_queues_per_port(port);
+
+	/* Free enqueued mbufs */
+	for (qindex = 0; qindex < n_queues_per_port; qindex++) {
+		struct rte_mbuf **mbufs = rte_sched_port_qbase(port, qindex);
+		uint16_t qsize = rte_sched_port_qsize(port, qindex);
+		struct rte_sched_queue *queue = port->queue + qindex;
+		uint16_t qr = queue->qr & (qsize - 1);
+		uint16_t qw = queue->qw & (qsize - 1);
+
+		for (; qr != qw; qr = (qr + 1) & (qsize - 1))
+			rte_pktmbuf_free(mbufs[qr]);
+	}
 
-	rte_free(port->subport_profiles);
+	rte_bitmap_free(port->bmp);
 	rte_free(port);
 }
 
 static void
-rte_sched_free_memory(struct rte_sched_port *port, uint32_t n_subports)
+rte_sched_port_log_subport_config(struct rte_sched_port *port, uint32_t i)
 {
-	uint32_t i;
+	struct rte_sched_subport *s = port->subport + i;
 
-	for (i = 0; i < n_subports; i++) {
-		struct rte_sched_subport *subport = port->subports[i];
+	RTE_LOG(DEBUG, SCHED, "Low level config for subport %u:\n"
+		"    Token bucket: period = %u, credits per period = %u, size = %u\n"
+		"    Traffic classes: period = %u, credits per period = [%u, %u, %u, %u]\n"
+		"    Traffic class 3 oversubscription: wm min = %u, wm max = %u\n",
+		i,
 
-		rte_sched_subport_free(port, subport);
-	}
+		/* Token bucket */
+		s->tb_period,
+		s->tb_credits_per_period,
+		s->tb_size,
 
-	rte_free(port->subport_profiles);
-	rte_free(port);
+		/* Traffic classes */
+		s->tc_period,
+		s->tc_credits_per_period[0],
+		s->tc_credits_per_period[1],
+		s->tc_credits_per_period[2],
+		s->tc_credits_per_period[3],
+
+		/* Traffic class 3 oversubscription */
+		s->tc_ov_wm_min,
+		s->tc_ov_wm_max);
 }
 
 int
 rte_sched_subport_config(struct rte_sched_port *port,
 	uint32_t subport_id,
-	struct rte_sched_subport_params *params,
-	uint32_t subport_profile_id)
+	struct rte_sched_subport_params *params)
 {
-	struct rte_sched_subport *s = NULL;
-	uint32_t n_subports = subport_id;
-	struct rte_sched_subport_profile *profile;
-	uint32_t n_subport_pipe_queues, i;
-	uint32_t size0, size1, bmp_mem_size;
-	int status;
+	struct rte_sched_subport *s;
+	uint32_t i;
 
 	/* Check user parameters */
-	if (port == NULL) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for parameter port\n", __func__);
-		return 0;
-	}
+	if (port == NULL ||
+	    subport_id >= port->n_subports_per_port ||
+	    params == NULL)
+		return -1;
 
-	if (subport_id >= port->n_subports_per_port) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for subport id\n", __func__);
-
-		rte_sched_free_memory(port, n_subports);
-		return -EINVAL;
-	}
-
-	if (subport_profile_id >= port->n_max_subport_profiles) {
-		RTE_LOG(ERR, SCHED, "%s: "
-			"Number of subport profile exceeds the max limit\n",
-			__func__);
-		rte_sched_free_memory(port, n_subports);
-		return -EINVAL;
-	}
-
-	/** Memory is allocated only on first invocation of the api for a
-	 * given subport. Subsequent invocation on same subport will just
-	 * update subport bandwidth parameter.
-	 **/
-	if (port->subports[subport_id] == NULL) {
-
-		status = rte_sched_subport_check_params(params,
-			port->n_pipes_per_subport,
-			port->rate);
-		if (status != 0) {
-			RTE_LOG(NOTICE, SCHED,
-				"%s: Port scheduler params check failed (%d)\n",
-				__func__, status);
+	if (params->tb_rate == 0 || params->tb_rate > port->rate)
+		return -2;
 
-			rte_sched_free_memory(port, n_subports);
-			return -EINVAL;
-		}
-
-		/* Determine the amount of memory to allocate */
-		size0 = sizeof(struct rte_sched_subport);
-		size1 = rte_sched_subport_get_array_base(params,
-					e_RTE_SCHED_SUBPORT_ARRAY_TOTAL);
-
-		/* Allocate memory to store the data structures */
-		s = rte_zmalloc_socket("subport_params", size0 + size1,
-			RTE_CACHE_LINE_SIZE, port->socket);
-		if (s == NULL) {
-			RTE_LOG(ERR, SCHED,
-				"%s: Memory allocation fails\n", __func__);
-
-			rte_sched_free_memory(port, n_subports);
-			return -ENOMEM;
-		}
+	if (params->tb_size == 0)
+		return -3;
 
-		n_subports++;
-
-		subport_profile_id = 0;
-
-		/* Port */
-		port->subports[subport_id] = s;
-
-		s->tb_time = port->time;
-
-		/* compile time checks */
-		RTE_BUILD_BUG_ON(RTE_SCHED_PORT_N_GRINDERS == 0);
-		RTE_BUILD_BUG_ON(RTE_SCHED_PORT_N_GRINDERS &
-			(RTE_SCHED_PORT_N_GRINDERS - 1));
-
-		/* User parameters */
-		s->n_pipes_per_subport_enabled =
-				params->n_pipes_per_subport_enabled;
-		memcpy(s->qsize, params->qsize, sizeof(params->qsize));
-		s->n_pipe_profiles = params->n_pipe_profiles;
-		s->n_max_pipe_profiles = params->n_max_pipe_profiles;
-
-#ifdef RTE_SCHED_RED
-		for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++) {
-			uint32_t j;
-
-			for (j = 0; j < RTE_COLORS; j++) {
-			/* if min/max are both zero, then RED is disabled */
-				if ((params->red_params[i][j].min_th |
-				     params->red_params[i][j].max_th) == 0) {
-					continue;
-				}
-
-				if (rte_red_config_init(&s->red_config[i][j],
-				    params->red_params[i][j].wq_log2,
-				    params->red_params[i][j].min_th,
-				    params->red_params[i][j].max_th,
-				    params->red_params[i][j].maxp_inv) != 0) {
-					rte_sched_free_memory(port, n_subports);
-
-					RTE_LOG(NOTICE, SCHED,
-					"%s: RED configuration init fails\n",
-					__func__);
-					return -EINVAL;
-				}
-			}
-		}
-#endif
+	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++) {
+		if (params->tc_rate[i] == 0 ||
+		    params->tc_rate[i] > params->tb_rate)
+			return -4;
+	}
 
-		/* Scheduling loop detection */
-		s->pipe_loop = RTE_SCHED_PIPE_INVALID;
-		s->pipe_exhaustion = 0;
-
-		/* Grinders */
-		s->busy_grinders = 0;
-
-		/* Queue base calculation */
-		rte_sched_subport_config_qsize(s);
-
-		/* Large data structures */
-		s->pipe = (struct rte_sched_pipe *)
-			(s->memory + rte_sched_subport_get_array_base(params,
-			e_RTE_SCHED_SUBPORT_ARRAY_PIPE));
-		s->queue = (struct rte_sched_queue *)
-			(s->memory + rte_sched_subport_get_array_base(params,
-			e_RTE_SCHED_SUBPORT_ARRAY_QUEUE));
-		s->queue_extra = (struct rte_sched_queue_extra *)
-			(s->memory + rte_sched_subport_get_array_base(params,
-			e_RTE_SCHED_SUBPORT_ARRAY_QUEUE_EXTRA));
-		s->pipe_profiles = (struct rte_sched_pipe_profile *)
-			(s->memory + rte_sched_subport_get_array_base(params,
-			e_RTE_SCHED_SUBPORT_ARRAY_PIPE_PROFILES));
-		s->bmp_array =  s->memory + rte_sched_subport_get_array_base(
-				params, e_RTE_SCHED_SUBPORT_ARRAY_BMP_ARRAY);
-		s->queue_array = (struct rte_mbuf **)
-			(s->memory + rte_sched_subport_get_array_base(params,
-			e_RTE_SCHED_SUBPORT_ARRAY_QUEUE_ARRAY));
-
-		/* Pipe profile table */
-		rte_sched_subport_config_pipe_profile_table(s, params,
-							    port->rate);
-
-		/* Bitmap */
-		n_subport_pipe_queues = rte_sched_subport_pipe_queues(s);
-		bmp_mem_size = rte_bitmap_get_memory_footprint(
-						n_subport_pipe_queues);
-		s->bmp = rte_bitmap_init(n_subport_pipe_queues, s->bmp_array,
-					bmp_mem_size);
-		if (s->bmp == NULL) {
-			RTE_LOG(ERR, SCHED,
-				"%s: Subport bitmap init error\n", __func__);
+	if (params->tc_period == 0)
+		return -5;
 
-			rte_sched_free_memory(port, n_subports);
-			return -EINVAL;
-		}
+	s = port->subport + subport_id;
 
-		for (i = 0; i < RTE_SCHED_PORT_N_GRINDERS; i++)
-			s->grinder_base_bmp_pos[i] = RTE_SCHED_PIPE_INVALID;
+	/* Token Bucket (TB) */
+	if (params->tb_rate == port->rate) {
+		s->tb_credits_per_period = 1;
+		s->tb_period = 1;
+	} else {
+		double tb_rate = ((double) params->tb_rate) / ((double) port->rate);
+		double d = RTE_SCHED_TB_RATE_CONFIG_ERR;
 
-#ifdef RTE_SCHED_SUBPORT_TC_OV
-		/* TC oversubscription */
-		s->tc_ov_wm_min = port->mtu;
-		s->tc_ov_wm = s->tc_ov_wm_max;
-		s->tc_ov_period_id = 0;
-		s->tc_ov = 0;
-		s->tc_ov_n = 0;
-		s->tc_ov_rate = 0;
-#endif
+		rte_approx(tb_rate, d, &s->tb_credits_per_period, &s->tb_period);
 	}
 
-	{
-	/* update subport parameters from subport profile table*/
-		profile = port->subport_profiles + subport_profile_id;
-
-		s = port->subports[subport_id];
-
-		s->tb_credits = profile->tb_size / 2;
+	s->tb_size = params->tb_size;
+	s->tb_time = port->time;
+	s->tb_credits = s->tb_size / 2;
 
-		s->tc_time = port->time + profile->tc_period;
-
-		for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++)
-			if (s->qsize[i])
-				s->tc_credits[i] =
-					profile->tc_credits_per_period[i];
-			else
-				profile->tc_credits_per_period[i] = 0;
+	/* Traffic Classes (TCs) */
+	s->tc_period = rte_sched_time_ms_to_bytes(params->tc_period, port->rate);
+	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++) {
+		s->tc_credits_per_period[i]
+			= rte_sched_time_ms_to_bytes(params->tc_period,
+						     params->tc_rate[i]);
+	}
+	s->tc_time = port->time + s->tc_period;
+	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++)
+		s->tc_credits[i] = s->tc_credits_per_period[i];
 
 #ifdef RTE_SCHED_SUBPORT_TC_OV
-		s->tc_ov_wm_max = rte_sched_time_ms_to_bytes(profile->tc_period,
-							s->pipe_tc_be_rate_max);
+	/* TC oversubscription */
+	s->tc_ov_wm_min = port->mtu;
+	s->tc_ov_wm_max = rte_sched_time_ms_to_bytes(params->tc_period,
+						     port->pipe_tc3_rate_max);
+	s->tc_ov_wm = s->tc_ov_wm_max;
+	s->tc_ov_period_id = 0;
+	s->tc_ov = 0;
+	s->tc_ov_n = 0;
+	s->tc_ov_rate = 0;
 #endif
-		s->profile = subport_profile_id;
 
-	}
-
-	rte_sched_port_log_subport_profile(port, subport_profile_id);
+	rte_sched_port_log_subport_config(port, subport_id);
 
 	return 0;
 }
@@ -1294,71 +875,50 @@ rte_sched_pipe_config(struct rte_sched_p
 	int32_t pipe_profile)
 {
 	struct rte_sched_subport *s;
-	struct rte_sched_subport_profile *sp;
 	struct rte_sched_pipe *p;
 	struct rte_sched_pipe_profile *params;
-	uint32_t n_subports = subport_id + 1;
 	uint32_t deactivate, profile, i;
 
 	/* Check user parameters */
 	profile = (uint32_t) pipe_profile;
 	deactivate = (pipe_profile < 0);
 
-	if (port == NULL) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for parameter port\n", __func__);
-		return -EINVAL;
-	}
-
-	if (subport_id >= port->n_subports_per_port) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for parameter subport id\n", __func__);
+	if (port == NULL ||
+	    subport_id >= port->n_subports_per_port ||
+	    pipe_id >= port->n_pipes_per_subport ||
+	    (!deactivate && profile >= port->n_pipe_profiles))
+		return -1;
 
-		rte_sched_free_memory(port, n_subports);
-		return -EINVAL;
-	}
-
-	s = port->subports[subport_id];
-	if (pipe_id >= s->n_pipes_per_subport_enabled) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for parameter pipe id\n", __func__);
-
-		rte_sched_free_memory(port, n_subports);
-		return -EINVAL;
-	}
 
-	if (!deactivate && profile >= s->n_pipe_profiles) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for parameter pipe profile\n", __func__);
+	/* Check that subport configuration is valid */
+	s = port->subport + subport_id;
+	if (s->tb_period == 0)
+		return -2;
 
-		rte_sched_free_memory(port, n_subports);
-		return -EINVAL;
-	}
+	p = port->pipe + (subport_id * port->n_pipes_per_subport + pipe_id);
 
-	sp = port->subport_profiles + s->profile;
 	/* Handle the case when pipe already has a valid configuration */
-	p = s->pipe + pipe_id;
 	if (p->tb_time) {
-		params = s->pipe_profiles + p->profile;
+		params = port->pipe_profiles + p->profile;
 
-		double subport_tc_be_rate =
-		(double)sp->tc_credits_per_period[RTE_SCHED_TRAFFIC_CLASS_BE]
-			/ (double) sp->tc_period;
-		double pipe_tc_be_rate =
-			(double) params->tc_credits_per_period[RTE_SCHED_TRAFFIC_CLASS_BE]
+#ifdef RTE_SCHED_SUBPORT_TC_OV
+		double subport_tc3_rate = (double) s->tc_credits_per_period[3]
+			/ (double) s->tc_period;
+		double pipe_tc3_rate = (double) params->tc_credits_per_period[3]
 			/ (double) params->tc_period;
-		uint32_t tc_be_ov = s->tc_ov;
+		uint32_t tc3_ov = s->tc_ov;
 
 		/* Unplug pipe from its subport */
 		s->tc_ov_n -= params->tc_ov_weight;
-		s->tc_ov_rate -= pipe_tc_be_rate;
-		s->tc_ov = s->tc_ov_rate > subport_tc_be_rate;
+		s->tc_ov_rate -= pipe_tc3_rate;
+		s->tc_ov = s->tc_ov_rate > subport_tc3_rate;
 
-		if (s->tc_ov != tc_be_ov) {
+		if (s->tc_ov != tc3_ov) {
 			RTE_LOG(DEBUG, SCHED,
-				"Subport %u Best-effort TC oversubscription is OFF (%.4lf >= %.4lf)\n",
-				subport_id, subport_tc_be_rate, s->tc_ov_rate);
+				"Subport %u TC3 oversubscription is OFF (%.4lf >= %.4lf)\n",
+				subport_id, subport_tc3_rate, s->tc_ov_rate);
 		}
+#endif
 
 		/* Reset the pipe */
 		memset(p, 0, sizeof(struct rte_sched_pipe));
@@ -1369,7 +929,7 @@ rte_sched_pipe_config(struct rte_sched_p
 
 	/* Apply the new pipe configuration */
 	p->profile = profile;
-	params = s->pipe_profiles + p->profile;
+	params = port->pipe_profiles + p->profile;
 
 	/* Token Bucket (TB) */
 	p->tb_time = port->time;
@@ -1377,215 +937,115 @@ rte_sched_pipe_config(struct rte_sched_p
 
 	/* Traffic Classes (TCs) */
 	p->tc_time = port->time + params->tc_period;
-
 	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++)
-		if (s->qsize[i])
-			p->tc_credits[i] = params->tc_credits_per_period[i];
+		p->tc_credits[i] = params->tc_credits_per_period[i];
 
+#ifdef RTE_SCHED_SUBPORT_TC_OV
 	{
-		/* Subport best effort tc oversubscription */
-		double subport_tc_be_rate =
-		(double)sp->tc_credits_per_period[RTE_SCHED_TRAFFIC_CLASS_BE]
-			/ (double) sp->tc_period;
-		double pipe_tc_be_rate =
-			(double) params->tc_credits_per_period[RTE_SCHED_TRAFFIC_CLASS_BE]
+		/* Subport TC3 oversubscription */
+		double subport_tc3_rate = (double) s->tc_credits_per_period[3]
+			/ (double) s->tc_period;
+		double pipe_tc3_rate = (double) params->tc_credits_per_period[3]
 			/ (double) params->tc_period;
-		uint32_t tc_be_ov = s->tc_ov;
+		uint32_t tc3_ov = s->tc_ov;
 
 		s->tc_ov_n += params->tc_ov_weight;
-		s->tc_ov_rate += pipe_tc_be_rate;
-		s->tc_ov = s->tc_ov_rate > subport_tc_be_rate;
+		s->tc_ov_rate += pipe_tc3_rate;
+		s->tc_ov = s->tc_ov_rate > subport_tc3_rate;
 
-		if (s->tc_ov != tc_be_ov) {
+		if (s->tc_ov != tc3_ov) {
 			RTE_LOG(DEBUG, SCHED,
-				"Subport %u Best effort TC oversubscription is ON (%.4lf < %.4lf)\n",
-				subport_id, subport_tc_be_rate, s->tc_ov_rate);
+				"Subport %u TC3 oversubscription is ON (%.4lf < %.4lf)\n",
+				subport_id, subport_tc3_rate, s->tc_ov_rate);
 		}
 		p->tc_ov_period_id = s->tc_ov_period_id;
 		p->tc_ov_credits = s->tc_ov_wm;
 	}
+#endif
 
 	return 0;
 }
 
-int
-rte_sched_subport_pipe_profile_add(struct rte_sched_port *port,
-	uint32_t subport_id,
+int __rte_experimental
+rte_sched_port_pipe_profile_add(struct rte_sched_port *port,
 	struct rte_sched_pipe_params *params,
 	uint32_t *pipe_profile_id)
 {
-	struct rte_sched_subport *s;
 	struct rte_sched_pipe_profile *pp;
 	uint32_t i;
 	int status;
 
 	/* Port */
-	if (port == NULL) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for parameter port\n", __func__);
-		return -EINVAL;
-	}
-
-	/* Subport id not exceeds the max limit */
-	if (subport_id > port->n_subports_per_port) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for subport id\n", __func__);
-		return -EINVAL;
-	}
-
-	s = port->subports[subport_id];
-
-	/* Pipe profiles exceeds the max limit */
-	if (s->n_pipe_profiles >= s->n_max_pipe_profiles) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Number of pipe profiles exceeds the max limit\n", __func__);
-		return -EINVAL;
-	}
+	if (port == NULL)
+		return -1;
 
-	/* Pipe params */
-	status = pipe_profile_check(params, port->rate, &s->qsize[0]);
-	if (status != 0) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Pipe profile check failed(%d)\n", __func__, status);
-		return -EINVAL;
-	}
+	/* Pipe profiles not exceeds the max limit */
+	if (port->n_pipe_profiles >= RTE_SCHED_PIPE_PROFILES_PER_PORT)
+		return -2;
 
-	pp = &s->pipe_profiles[s->n_pipe_profiles];
-	rte_sched_pipe_profile_convert(s, params, pp, port->rate);
-
-	/* Pipe profile should not exists */
-	for (i = 0; i < s->n_pipe_profiles; i++)
-		if (memcmp(s->pipe_profiles + i, pp, sizeof(*pp)) == 0) {
-			RTE_LOG(ERR, SCHED,
-				"%s: Pipe profile exists\n", __func__);
-			return -EINVAL;
-		}
+	/* Pipe params */
+	status = pipe_profile_check(params, port->rate);
+	if (status != 0)
+		return status;
+
+	pp = &port->pipe_profiles[port->n_pipe_profiles];
+	rte_sched_pipe_profile_convert(params, pp, port->rate);
+
+	/* Pipe profile not exists */
+	for (i = 0; i < port->n_pipe_profiles; i++)
+		if (memcmp(port->pipe_profiles + i, pp, sizeof(*pp)) == 0)
+			return -3;
 
 	/* Pipe profile commit */
-	*pipe_profile_id = s->n_pipe_profiles;
-	s->n_pipe_profiles++;
+	*pipe_profile_id = port->n_pipe_profiles;
+	port->n_pipe_profiles++;
 
-	if (s->pipe_tc_be_rate_max < params->tc_rate[RTE_SCHED_TRAFFIC_CLASS_BE])
-		s->pipe_tc_be_rate_max = params->tc_rate[RTE_SCHED_TRAFFIC_CLASS_BE];
+	if (port->pipe_tc3_rate_max < params->tc_rate[3])
+		port->pipe_tc3_rate_max = params->tc_rate[3];
 
-	rte_sched_port_log_pipe_profile(s, *pipe_profile_id);
+	rte_sched_port_log_pipe_profile(port, *pipe_profile_id);
 
 	return 0;
 }
 
-int
-rte_sched_port_subport_profile_add(struct rte_sched_port *port,
-	struct rte_sched_subport_profile_params *params,
-	uint32_t *subport_profile_id)
-{
-	int status;
-	uint32_t i;
-	struct rte_sched_subport_profile *dst;
-
-	/* Port */
-	if (port == NULL) {
-		RTE_LOG(ERR, SCHED, "%s: "
-		"Incorrect value for parameter port\n", __func__);
-		return -EINVAL;
-	}
-
-	if (params == NULL) {
-		RTE_LOG(ERR, SCHED, "%s: "
-		"Incorrect value for parameter profile\n", __func__);
-		return -EINVAL;
-	}
-
-	if (subport_profile_id == NULL) {
-		RTE_LOG(ERR, SCHED, "%s: "
-		"Incorrect value for parameter subport_profile_id\n",
-		__func__);
-		return -EINVAL;
-	}
-
-	dst = port->subport_profiles + port->n_subport_profiles;
-
-	/* Subport profiles exceeds the max limit */
-	if (port->n_subport_profiles >= port->n_max_subport_profiles) {
-		RTE_LOG(ERR, SCHED, "%s: "
-		"Number of subport profiles exceeds the max limit\n",
-		 __func__);
-		return -EINVAL;
-	}
-
-	status = subport_profile_check(params, port->rate);
-	if (status != 0) {
-		RTE_LOG(ERR, SCHED,
-		"%s: subport profile check failed(%d)\n", __func__, status);
-		return -EINVAL;
-	}
-
-	rte_sched_subport_profile_convert(params, dst, port->rate);
-
-	/* Subport profile should not exists */
-	for (i = 0; i < port->n_subport_profiles; i++)
-		if (memcmp(port->subport_profiles + i,
-		    dst, sizeof(*dst)) == 0) {
-			RTE_LOG(ERR, SCHED,
-			"%s: subport profile exists\n", __func__);
-			return -EINVAL;
-		}
-
-	/* Subport profile commit */
-	*subport_profile_id = port->n_subport_profiles;
-	port->n_subport_profiles++;
-
-	rte_sched_port_log_subport_profile(port, *subport_profile_id);
-
-	return 0;
-}
-
-static inline uint32_t
-rte_sched_port_qindex(struct rte_sched_port *port,
-	uint32_t subport,
-	uint32_t pipe,
-	uint32_t traffic_class,
-	uint32_t queue)
-{
-	return ((subport & (port->n_subports_per_port - 1)) <<
-		(port->n_pipes_per_subport_log2 + 4)) |
-		((pipe &
-		(port->subports[subport]->n_pipes_per_subport_enabled - 1)) << 4) |
-		((rte_sched_port_pipe_queue(port, traffic_class) + queue) &
-		(RTE_SCHED_QUEUES_PER_PIPE - 1));
-}
-
 void
-rte_sched_port_pkt_write(struct rte_sched_port *port,
-			 struct rte_mbuf *pkt,
-			 uint32_t subport, uint32_t pipe,
-			 uint32_t traffic_class,
+rte_sched_port_pkt_write(struct rte_mbuf *pkt,
+			 uint32_t subport, uint32_t pipe, uint32_t traffic_class,
 			 uint32_t queue, enum rte_color color)
 {
-	uint32_t queue_id =
-		rte_sched_port_qindex(port, subport, pipe, traffic_class, queue);
+	struct rte_sched_port_hierarchy *sched
+		= (struct rte_sched_port_hierarchy *) &pkt->hash.sched;
+
+	RTE_BUILD_BUG_ON(sizeof(*sched) > sizeof(pkt->hash.sched));
 
-	rte_mbuf_sched_set(pkt, queue_id, traffic_class, (uint8_t)color);
+	sched->color = (uint32_t) color;
+	sched->subport = subport;
+	sched->pipe = pipe;
+	sched->traffic_class = traffic_class;
+	sched->queue = queue;
 }
 
 void
-rte_sched_port_pkt_read_tree_path(struct rte_sched_port *port,
-				  const struct rte_mbuf *pkt,
+rte_sched_port_pkt_read_tree_path(const struct rte_mbuf *pkt,
 				  uint32_t *subport, uint32_t *pipe,
 				  uint32_t *traffic_class, uint32_t *queue)
 {
-	uint32_t queue_id = rte_mbuf_sched_queue_get(pkt);
+	const struct rte_sched_port_hierarchy *sched
+		= (const struct rte_sched_port_hierarchy *) &pkt->hash.sched;
 
-	*subport = queue_id >> (port->n_pipes_per_subport_log2 + 4);
-	*pipe = (queue_id >> 4) &
-		(port->subports[*subport]->n_pipes_per_subport_enabled - 1);
-	*traffic_class = rte_sched_port_pipe_tc(port, queue_id);
-	*queue = rte_sched_port_tc_queue(port, queue_id);
+	*subport = sched->subport;
+	*pipe = sched->pipe;
+	*traffic_class = sched->traffic_class;
+	*queue = sched->queue;
 }
 
 enum rte_color
 rte_sched_port_pkt_read_color(const struct rte_mbuf *pkt)
 {
-	return (enum rte_color)rte_mbuf_sched_color_get(pkt);
+	const struct rte_sched_port_hierarchy *sched
+		= (const struct rte_sched_port_hierarchy *) &pkt->hash.sched;
+
+	return (enum rte_color) sched->color;
 }
 
 int
@@ -1597,31 +1057,11 @@ rte_sched_subport_read_stats(struct rte_
 	struct rte_sched_subport *s;
 
 	/* Check user parameters */
-	if (port == NULL) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for parameter port\n", __func__);
-		return -EINVAL;
-	}
-
-	if (subport_id >= port->n_subports_per_port) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for subport id\n", __func__);
-		return -EINVAL;
-	}
-
-	if (stats == NULL) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for parameter stats\n", __func__);
-		return -EINVAL;
-	}
-
-	if (tc_ov == NULL) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for tc_ov\n", __func__);
-		return -EINVAL;
-	}
+	if (port == NULL || subport_id >= port->n_subports_per_port ||
+	    stats == NULL || tc_ov == NULL)
+		return -1;
 
-	s = port->subports[subport_id];
+	s = port->subport + subport_id;
 
 	/* Copy subport stats and clear */
 	memcpy(stats, &s->stats, sizeof(struct rte_sched_subport_stats));
@@ -1639,42 +1079,18 @@ rte_sched_queue_read_stats(struct rte_sc
 	struct rte_sched_queue_stats *stats,
 	uint16_t *qlen)
 {
-	struct rte_sched_subport *s;
 	struct rte_sched_queue *q;
 	struct rte_sched_queue_extra *qe;
-	uint32_t subport_id, subport_qmask, subport_qindex;
 
 	/* Check user parameters */
-	if (port == NULL) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for parameter port\n", __func__);
-		return -EINVAL;
-	}
-
-	if (queue_id >= rte_sched_port_queues_per_port(port)) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for queue id\n", __func__);
-		return -EINVAL;
-	}
-
-	if (stats == NULL) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for parameter stats\n", __func__);
-		return -EINVAL;
-	}
-
-	if (qlen == NULL) {
-		RTE_LOG(ERR, SCHED,
-			"%s: Incorrect value for parameter qlen\n", __func__);
-		return -EINVAL;
+	if ((port == NULL) ||
+	    (queue_id >= rte_sched_port_queues_per_port(port)) ||
+		(stats == NULL) ||
+		(qlen == NULL)) {
+		return -1;
 	}
-	subport_qmask = port->n_pipes_per_subport_log2 + 4;
-	subport_id = (queue_id >> subport_qmask) & (port->n_subports_per_port - 1);
-
-	s = port->subports[subport_id];
-	subport_qindex = ((1 << subport_qmask) - 1) & queue_id;
-	q = s->queue + subport_qindex;
-	qe = s->queue_extra + subport_qindex;
+	q = port->queue + queue_id;
+	qe = port->queue_extra + queue_id;
 
 	/* Copy queue stats and clear */
 	memcpy(stats, &qe->stats, sizeof(struct rte_sched_queue_stats));
@@ -1686,13 +1102,24 @@ rte_sched_queue_read_stats(struct rte_sc
 	return 0;
 }
 
+static inline uint32_t
+rte_sched_port_qindex(struct rte_sched_port *port, uint32_t subport, uint32_t pipe, uint32_t traffic_class, uint32_t queue)
+{
+	uint32_t result;
+
+	result = subport * port->n_pipes_per_subport + pipe;
+	result = result * RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE + traffic_class;
+	result = result * RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS + queue;
+
+	return result;
+}
+
 #ifdef RTE_SCHED_DEBUG
 
 static inline int
-rte_sched_port_queue_is_empty(struct rte_sched_subport *subport,
-	uint32_t qindex)
+rte_sched_port_queue_is_empty(struct rte_sched_port *port, uint32_t qindex)
 {
-	struct rte_sched_queue *queue = subport->queue + qindex;
+	struct rte_sched_queue *queue = port->queue + qindex;
 
 	return queue->qr == queue->qw;
 }
@@ -1702,50 +1129,43 @@ rte_sched_port_queue_is_empty(struct rte
 #ifdef RTE_SCHED_COLLECT_STATS
 
 static inline void
-rte_sched_port_update_subport_stats(struct rte_sched_port *port,
-	struct rte_sched_subport *subport,
-	uint32_t qindex,
-	struct rte_mbuf *pkt)
+rte_sched_port_update_subport_stats(struct rte_sched_port *port, uint32_t qindex, struct rte_mbuf *pkt)
 {
-	uint32_t tc_index = rte_sched_port_pipe_tc(port, qindex);
+	struct rte_sched_subport *s = port->subport + (qindex / rte_sched_port_queues_per_subport(port));
+	uint32_t tc_index = (qindex >> 2) & 0x3;
 	uint32_t pkt_len = pkt->pkt_len;
 
-	subport->stats.n_pkts_tc[tc_index] += 1;
-	subport->stats.n_bytes_tc[tc_index] += pkt_len;
+	s->stats.n_pkts_tc[tc_index] += 1;
+	s->stats.n_bytes_tc[tc_index] += pkt_len;
 }
 
 #ifdef RTE_SCHED_RED
 static inline void
 rte_sched_port_update_subport_stats_on_drop(struct rte_sched_port *port,
-	struct rte_sched_subport *subport,
-	uint32_t qindex,
-	struct rte_mbuf *pkt,
-	uint32_t red)
+						uint32_t qindex,
+						struct rte_mbuf *pkt, uint32_t red)
 #else
 static inline void
 rte_sched_port_update_subport_stats_on_drop(struct rte_sched_port *port,
-	struct rte_sched_subport *subport,
-	uint32_t qindex,
-	struct rte_mbuf *pkt,
-	__rte_unused uint32_t red)
+						uint32_t qindex,
+						struct rte_mbuf *pkt, __rte_unused uint32_t red)
 #endif
 {
-	uint32_t tc_index = rte_sched_port_pipe_tc(port, qindex);
+	struct rte_sched_subport *s = port->subport + (qindex / rte_sched_port_queues_per_subport(port));
+	uint32_t tc_index = (qindex >> 2) & 0x3;
 	uint32_t pkt_len = pkt->pkt_len;
 
-	subport->stats.n_pkts_tc_dropped[tc_index] += 1;
-	subport->stats.n_bytes_tc_dropped[tc_index] += pkt_len;
+	s->stats.n_pkts_tc_dropped[tc_index] += 1;
+	s->stats.n_bytes_tc_dropped[tc_index] += pkt_len;
 #ifdef RTE_SCHED_RED
-	subport->stats.n_pkts_red_dropped[tc_index] += red;
+	s->stats.n_pkts_red_dropped[tc_index] += red;
 #endif
 }
 
 static inline void
-rte_sched_port_update_queue_stats(struct rte_sched_subport *subport,
-	uint32_t qindex,
-	struct rte_mbuf *pkt)
+rte_sched_port_update_queue_stats(struct rte_sched_port *port, uint32_t qindex, struct rte_mbuf *pkt)
 {
-	struct rte_sched_queue_extra *qe = subport->queue_extra + qindex;
+	struct rte_sched_queue_extra *qe = port->queue_extra + qindex;
 	uint32_t pkt_len = pkt->pkt_len;
 
 	qe->stats.n_pkts += 1;
@@ -1754,19 +1174,17 @@ rte_sched_port_update_queue_stats(struct
 
 #ifdef RTE_SCHED_RED
 static inline void
-rte_sched_port_update_queue_stats_on_drop(struct rte_sched_subport *subport,
-	uint32_t qindex,
-	struct rte_mbuf *pkt,
-	uint32_t red)
+rte_sched_port_update_queue_stats_on_drop(struct rte_sched_port *port,
+						uint32_t qindex,
+						struct rte_mbuf *pkt, uint32_t red)
 #else
 static inline void
-rte_sched_port_update_queue_stats_on_drop(struct rte_sched_subport *subport,
-	uint32_t qindex,
-	struct rte_mbuf *pkt,
-	__rte_unused uint32_t red)
+rte_sched_port_update_queue_stats_on_drop(struct rte_sched_port *port,
+						uint32_t qindex,
+						struct rte_mbuf *pkt, __rte_unused uint32_t red)
 #endif
 {
-	struct rte_sched_queue_extra *qe = subport->queue_extra + qindex;
+	struct rte_sched_queue_extra *qe = port->queue_extra + qindex;
 	uint32_t pkt_len = pkt->pkt_len;
 
 	qe->stats.n_pkts_dropped += 1;
@@ -1781,11 +1199,7 @@ rte_sched_port_update_queue_stats_on_dro
 #ifdef RTE_SCHED_RED
 
 static inline int
-rte_sched_port_red_drop(struct rte_sched_port *port,
-	struct rte_sched_subport *subport,
-	struct rte_mbuf *pkt,
-	uint32_t qindex,
-	uint16_t qlen)
+rte_sched_port_red_drop(struct rte_sched_port *port, struct rte_mbuf *pkt, uint32_t qindex, uint16_t qlen)
 {
 	struct rte_sched_queue_extra *qe;
 	struct rte_red_config *red_cfg;
@@ -1793,24 +1207,23 @@ rte_sched_port_red_drop(struct rte_sched
 	uint32_t tc_index;
 	enum rte_color color;
 
-	tc_index = rte_sched_port_pipe_tc(port, qindex);
+	tc_index = (qindex >> 2) & 0x3;
 	color = rte_sched_port_pkt_read_color(pkt);
-	red_cfg = &subport->red_config[tc_index][color];
+	red_cfg = &port->red_config[tc_index][color];
 
 	if ((red_cfg->min_th | red_cfg->max_th) == 0)
 		return 0;
 
-	qe = subport->queue_extra + qindex;
+	qe = port->queue_extra + qindex;
 	red = &qe->red;
 
 	return rte_red_enqueue(red_cfg, red, qlen, port->time);
 }
 
 static inline void
-rte_sched_port_set_queue_empty_timestamp(struct rte_sched_port *port,
-	struct rte_sched_subport *subport, uint32_t qindex)
+rte_sched_port_set_queue_empty_timestamp(struct rte_sched_port *port, uint32_t qindex)
 {
-	struct rte_sched_queue_extra *qe = subport->queue_extra + qindex;
+	struct rte_sched_queue_extra *qe = port->queue_extra + qindex;
 	struct rte_red *red = &qe->red;
 
 	rte_red_mark_queue_empty(red, port->time);
@@ -1818,23 +1231,16 @@ rte_sched_port_set_queue_empty_timestamp
 
 #else
 
-static inline int rte_sched_port_red_drop(struct rte_sched_port *port __rte_unused,
-	struct rte_sched_subport *subport __rte_unused,
-	struct rte_mbuf *pkt __rte_unused,
-	uint32_t qindex __rte_unused,
-	uint16_t qlen __rte_unused)
-{
-	return 0;
-}
+#define rte_sched_port_red_drop(port, pkt, qindex, qlen)             0
 
-#define rte_sched_port_set_queue_empty_timestamp(port, subport, qindex)
+#define rte_sched_port_set_queue_empty_timestamp(port, qindex)
 
 #endif /* RTE_SCHED_RED */
 
 #ifdef RTE_SCHED_DEBUG
 
 static inline void
-debug_check_queue_slab(struct rte_sched_subport *subport, uint32_t bmp_pos,
+debug_check_queue_slab(struct rte_sched_port *port, uint32_t bmp_pos,
 		       uint64_t bmp_slab)
 {
 	uint64_t mask;
@@ -1846,7 +1252,7 @@ debug_check_queue_slab(struct rte_sched_
 	panic = 0;
 	for (i = 0, mask = 1; i < 64; i++, mask <<= 1) {
 		if (mask & bmp_slab) {
-			if (rte_sched_port_queue_is_empty(subport, bmp_pos + i)) {
+			if (rte_sched_port_queue_is_empty(port, bmp_pos + i)) {
 				printf("Queue %u (slab offset %u) is empty\n", bmp_pos + i, i);
 				panic = 1;
 			}
@@ -1860,79 +1266,66 @@ debug_check_queue_slab(struct rte_sched_
 
 #endif /* RTE_SCHED_DEBUG */
 
-static inline struct rte_sched_subport *
-rte_sched_port_subport(struct rte_sched_port *port,
-	struct rte_mbuf *pkt)
-{
-	uint32_t queue_id = rte_mbuf_sched_queue_get(pkt);
-	uint32_t subport_id = queue_id >> (port->n_pipes_per_subport_log2 + 4);
-
-	return port->subports[subport_id];
-}
-
 static inline uint32_t
-rte_sched_port_enqueue_qptrs_prefetch0(struct rte_sched_subport *subport,
-	struct rte_mbuf *pkt, uint32_t subport_qmask)
+rte_sched_port_enqueue_qptrs_prefetch0(struct rte_sched_port *port,
+				       struct rte_mbuf *pkt)
 {
 	struct rte_sched_queue *q;
 #ifdef RTE_SCHED_COLLECT_STATS
 	struct rte_sched_queue_extra *qe;
 #endif
-	uint32_t qindex = rte_mbuf_sched_queue_get(pkt);
-	uint32_t subport_queue_id = subport_qmask & qindex;
+	uint32_t subport, pipe, traffic_class, queue, qindex;
 
-	q = subport->queue + subport_queue_id;
+	rte_sched_port_pkt_read_tree_path(pkt, &subport, &pipe, &traffic_class, &queue);
+
+	qindex = rte_sched_port_qindex(port, subport, pipe, traffic_class, queue);
+	q = port->queue + qindex;
 	rte_prefetch0(q);
 #ifdef RTE_SCHED_COLLECT_STATS
-	qe = subport->queue_extra + subport_queue_id;
+	qe = port->queue_extra + qindex;
 	rte_prefetch0(qe);
 #endif
 
-	return subport_queue_id;
+	return qindex;
 }
 
 static inline void
 rte_sched_port_enqueue_qwa_prefetch0(struct rte_sched_port *port,
-	struct rte_sched_subport *subport,
-	uint32_t qindex,
-	struct rte_mbuf **qbase)
+				     uint32_t qindex, struct rte_mbuf **qbase)
 {
 	struct rte_sched_queue *q;
 	struct rte_mbuf **q_qw;
 	uint16_t qsize;
 
-	q = subport->queue + qindex;
-	qsize = rte_sched_subport_pipe_qsize(port, subport, qindex);
+	q = port->queue + qindex;
+	qsize = rte_sched_port_qsize(port, qindex);
 	q_qw = qbase + (q->qw & (qsize - 1));
 
 	rte_prefetch0(q_qw);
-	rte_bitmap_prefetch0(subport->bmp, qindex);
+	rte_bitmap_prefetch0(port->bmp, qindex);
 }
 
 static inline int
-rte_sched_port_enqueue_qwa(struct rte_sched_port *port,
-	struct rte_sched_subport *subport,
-	uint32_t qindex,
-	struct rte_mbuf **qbase,
-	struct rte_mbuf *pkt)
+rte_sched_port_enqueue_qwa(struct rte_sched_port *port, uint32_t qindex,
+			   struct rte_mbuf **qbase, struct rte_mbuf *pkt)
 {
 	struct rte_sched_queue *q;
 	uint16_t qsize;
 	uint16_t qlen;
 
-	q = subport->queue + qindex;
-	qsize = rte_sched_subport_pipe_qsize(port, subport, qindex);
+	q = port->queue + qindex;
+	qsize = rte_sched_port_qsize(port, qindex);
 	qlen = q->qw - q->qr;
 
 	/* Drop the packet (and update drop stats) when queue is full */
-	if (unlikely(rte_sched_port_red_drop(port, subport, pkt, qindex, qlen) ||
+	if (unlikely(rte_sched_port_red_drop(port, pkt, qindex, qlen) ||
 		     (qlen >= qsize))) {
 		rte_pktmbuf_free(pkt);
 #ifdef RTE_SCHED_COLLECT_STATS
-		rte_sched_port_update_subport_stats_on_drop(port, subport,
-			qindex, pkt, qlen < qsize);
-		rte_sched_port_update_queue_stats_on_drop(subport, qindex, pkt,
-			qlen < qsize);
+		rte_sched_port_update_subport_stats_on_drop(port, qindex, pkt,
+							    qlen < qsize);
+		rte_sched_port_update_queue_stats_on_drop(port, qindex, pkt,
+							  qlen < qsize);
 #endif
 		return 0;
 	}
@@ -1941,13 +1334,13 @@ rte_sched_port_enqueue_qwa(struct rte_sc
 	qbase[q->qw & (qsize - 1)] = pkt;
 	q->qw++;
 
-	/* Activate queue in the subport bitmap */
-	rte_bitmap_set(subport->bmp, qindex);
+	/* Activate queue in the port bitmap */
+	rte_bitmap_set(port->bmp, qindex);
 
 	/* Statistics */
 #ifdef RTE_SCHED_COLLECT_STATS
-	rte_sched_port_update_subport_stats(port, subport, qindex, pkt);
-	rte_sched_port_update_queue_stats(subport, qindex, pkt);
+	rte_sched_port_update_subport_stats(port, qindex, pkt);
+	rte_sched_port_update_queue_stats(port, qindex, pkt);
 #endif
 
 	return 1;
@@ -1975,22 +1368,17 @@ rte_sched_port_enqueue(struct rte_sched_
 		*pkt30, *pkt31, *pkt_last;
 	struct rte_mbuf **q00_base, **q01_base, **q10_base, **q11_base,
 		**q20_base, **q21_base, **q30_base, **q31_base, **q_last_base;
-	struct rte_sched_subport *subport00, *subport01, *subport10, *subport11,
-		*subport20, *subport21, *subport30, *subport31, *subport_last;
 	uint32_t q00, q01, q10, q11, q20, q21, q30, q31, q_last;
 	uint32_t r00, r01, r10, r11, r20, r21, r30, r31, r_last;
-	uint32_t subport_qmask;
 	uint32_t result, i;
 
 	result = 0;
-	subport_qmask = (1 << (port->n_pipes_per_subport_log2 + 4)) - 1;
 
 	/*
 	 * Less then 6 input packets available, which is not enough to
 	 * feed the pipeline
 	 */
 	if (unlikely(n_pkts < 6)) {
-		struct rte_sched_subport *subports[5];
 		struct rte_mbuf **q_base[5];
 		uint32_t q[5];
 
@@ -1998,26 +1386,22 @@ rte_sched_port_enqueue(struct rte_sched_
 		for (i = 0; i < n_pkts; i++)
 			rte_prefetch0(pkts[i]);
 
-		/* Prefetch the subport structure for each packet */
-		for (i = 0; i < n_pkts; i++)
-			subports[i] = rte_sched_port_subport(port, pkts[i]);
-
 		/* Prefetch the queue structure for each queue */
 		for (i = 0; i < n_pkts; i++)
-			q[i] = rte_sched_port_enqueue_qptrs_prefetch0(subports[i],
-					pkts[i], subport_qmask);
+			q[i] = rte_sched_port_enqueue_qptrs_prefetch0(port,
+								      pkts[i]);
 
 		/* Prefetch the write pointer location of each queue */
 		for (i = 0; i < n_pkts; i++) {
-			q_base[i] = rte_sched_subport_pipe_qbase(subports[i], q[i]);
-			rte_sched_port_enqueue_qwa_prefetch0(port, subports[i],
-				q[i], q_base[i]);
+			q_base[i] = rte_sched_port_qbase(port, q[i]);
+			rte_sched_port_enqueue_qwa_prefetch0(port, q[i],
+							     q_base[i]);
 		}
 
 		/* Write each packet to its queue */
 		for (i = 0; i < n_pkts; i++)
-			result += rte_sched_port_enqueue_qwa(port, subports[i],
-						q[i], q_base[i], pkts[i]);
+			result += rte_sched_port_enqueue_qwa(port, q[i],
+							     q_base[i], pkts[i]);
 
 		return result;
 	}
@@ -2033,29 +1417,21 @@ rte_sched_port_enqueue(struct rte_sched_
 	rte_prefetch0(pkt10);
 	rte_prefetch0(pkt11);
 
-	subport20 = rte_sched_port_subport(port, pkt20);
-	subport21 = rte_sched_port_subport(port, pkt21);
-	q20 = rte_sched_port_enqueue_qptrs_prefetch0(subport20,
-			pkt20, subport_qmask);
-	q21 = rte_sched_port_enqueue_qptrs_prefetch0(subport21,
-			pkt21, subport_qmask);
+	q20 = rte_sched_port_enqueue_qptrs_prefetch0(port, pkt20);
+	q21 = rte_sched_port_enqueue_qptrs_prefetch0(port, pkt21);
 
 	pkt00 = pkts[4];
 	pkt01 = pkts[5];
 	rte_prefetch0(pkt00);
 	rte_prefetch0(pkt01);
 
-	subport10 = rte_sched_port_subport(port, pkt10);
-	subport11 = rte_sched_port_subport(port, pkt11);
-	q10 = rte_sched_port_enqueue_qptrs_prefetch0(subport10,
-			pkt10, subport_qmask);
-	q11 = rte_sched_port_enqueue_qptrs_prefetch0(subport11,
-			pkt11, subport_qmask);
-
-	q20_base = rte_sched_subport_pipe_qbase(subport20, q20);
-	q21_base = rte_sched_subport_pipe_qbase(subport21, q21);
-	rte_sched_port_enqueue_qwa_prefetch0(port, subport20, q20, q20_base);
-	rte_sched_port_enqueue_qwa_prefetch0(port, subport21, q21, q21_base);
+	q10 = rte_sched_port_enqueue_qptrs_prefetch0(port, pkt10);
+	q11 = rte_sched_port_enqueue_qptrs_prefetch0(port, pkt11);
+
+	q20_base = rte_sched_port_qbase(port, q20);
+	q21_base = rte_sched_port_qbase(port, q21);
+	rte_sched_port_enqueue_qwa_prefetch0(port, q20, q20_base);
+	rte_sched_port_enqueue_qwa_prefetch0(port, q21, q21_base);
 
 	/* Run the pipeline */
 	for (i = 6; i < (n_pkts & (~1)); i += 2) {
@@ -2070,10 +1446,6 @@ rte_sched_port_enqueue(struct rte_sched_
 		q31 = q21;
 		q20 = q10;
 		q21 = q11;
-		subport30 = subport20;
-		subport31 = subport21;
-		subport20 = subport10;
-		subport21 = subport11;
 		q30_base = q20_base;
 		q31_base = q21_base;
 
@@ -2083,25 +1455,19 @@ rte_sched_port_enqueue(struct rte_sched_
 		rte_prefetch0(pkt00);
 		rte_prefetch0(pkt01);
 
-		/* Stage 1: Prefetch subport and queue structure storing queue pointers */
-		subport10 = rte_sched_port_subport(port, pkt10);
-		subport11 = rte_sched_port_subport(port, pkt11);
-		q10 = rte_sched_port_enqueue_qptrs_prefetch0(subport10,
-				pkt10, subport_qmask);
-		q11 = rte_sched_port_enqueue_qptrs_prefetch0(subport11,
-				pkt11, subport_qmask);
+		/* Stage 1: Prefetch queue structure storing queue pointers */
+		q10 = rte_sched_port_enqueue_qptrs_prefetch0(port, pkt10);
+		q11 = rte_sched_port_enqueue_qptrs_prefetch0(port, pkt11);
 
 		/* Stage 2: Prefetch queue write location */
-		q20_base = rte_sched_subport_pipe_qbase(subport20, q20);
-		q21_base = rte_sched_subport_pipe_qbase(subport21, q21);
-		rte_sched_port_enqueue_qwa_prefetch0(port, subport20, q20, q20_base);
-		rte_sched_port_enqueue_qwa_prefetch0(port, subport21, q21, q21_base);
+		q20_base = rte_sched_port_qbase(port, q20);
+		q21_base = rte_sched_port_qbase(port, q21);
+		rte_sched_port_enqueue_qwa_prefetch0(port, q20, q20_base);
+		rte_sched_port_enqueue_qwa_prefetch0(port, q21, q21_base);
 
 		/* Stage 3: Write packet to queue and activate queue */
-		r30 = rte_sched_port_enqueue_qwa(port, subport30,
-				q30, q30_base, pkt30);
-		r31 = rte_sched_port_enqueue_qwa(port, subport31,
-				q31, q31_base, pkt31);
+		r30 = rte_sched_port_enqueue_qwa(port, q30, q30_base, pkt30);
+		r31 = rte_sched_port_enqueue_qwa(port, q31, q31_base, pkt31);
 		result += r30 + r31;
 	}
 
@@ -2113,52 +1479,38 @@ rte_sched_port_enqueue(struct rte_sched_
 	pkt_last = pkts[n_pkts - 1];
 	rte_prefetch0(pkt_last);
 
-	subport00 = rte_sched_port_subport(port, pkt00);
-	subport01 = rte_sched_port_subport(port, pkt01);
-	q00 = rte_sched_port_enqueue_qptrs_prefetch0(subport00,
-			pkt00, subport_qmask);
-	q01 = rte_sched_port_enqueue_qptrs_prefetch0(subport01,
-			pkt01, subport_qmask);
-
-	q10_base = rte_sched_subport_pipe_qbase(subport10, q10);
-	q11_base = rte_sched_subport_pipe_qbase(subport11, q11);
-	rte_sched_port_enqueue_qwa_prefetch0(port, subport10, q10, q10_base);
-	rte_sched_port_enqueue_qwa_prefetch0(port, subport11, q11, q11_base);
-
-	r20 = rte_sched_port_enqueue_qwa(port, subport20,
-			q20, q20_base, pkt20);
-	r21 = rte_sched_port_enqueue_qwa(port, subport21,
-			q21, q21_base, pkt21);
+	q00 = rte_sched_port_enqueue_qptrs_prefetch0(port, pkt00);
+	q01 = rte_sched_port_enqueue_qptrs_prefetch0(port, pkt01);
+
+	q10_base = rte_sched_port_qbase(port, q10);
+	q11_base = rte_sched_port_qbase(port, q11);
+	rte_sched_port_enqueue_qwa_prefetch0(port, q10, q10_base);
+	rte_sched_port_enqueue_qwa_prefetch0(port, q11, q11_base);
+
+	r20 = rte_sched_port_enqueue_qwa(port, q20, q20_base, pkt20);
+	r21 = rte_sched_port_enqueue_qwa(port, q21, q21_base, pkt21);
 	result += r20 + r21;
 
-	subport_last = rte_sched_port_subport(port, pkt_last);
-	q_last = rte_sched_port_enqueue_qptrs_prefetch0(subport_last,
-				pkt_last, subport_qmask);
-
-	q00_base = rte_sched_subport_pipe_qbase(subport00, q00);
-	q01_base = rte_sched_subport_pipe_qbase(subport01, q01);
-	rte_sched_port_enqueue_qwa_prefetch0(port, subport00, q00, q00_base);
-	rte_sched_port_enqueue_qwa_prefetch0(port, subport01, q01, q01_base);
-
-	r10 = rte_sched_port_enqueue_qwa(port, subport10, q10,
-			q10_base, pkt10);
-	r11 = rte_sched_port_enqueue_qwa(port, subport11, q11,
-			q11_base, pkt11);
+	q_last = rte_sched_port_enqueue_qptrs_prefetch0(port, pkt_last);
+
+	q00_base = rte_sched_port_qbase(port, q00);
+	q01_base = rte_sched_port_qbase(port, q01);
+	rte_sched_port_enqueue_qwa_prefetch0(port, q00, q00_base);
+	rte_sched_port_enqueue_qwa_prefetch0(port, q01, q01_base);
+
+	r10 = rte_sched_port_enqueue_qwa(port, q10, q10_base, pkt10);
+	r11 = rte_sched_port_enqueue_qwa(port, q11, q11_base, pkt11);
 	result += r10 + r11;
 
-	q_last_base = rte_sched_subport_pipe_qbase(subport_last, q_last);
-	rte_sched_port_enqueue_qwa_prefetch0(port, subport_last,
-		q_last, q_last_base);
-
-	r00 = rte_sched_port_enqueue_qwa(port, subport00, q00,
-			q00_base, pkt00);
-	r01 = rte_sched_port_enqueue_qwa(port, subport01, q01,
-			q01_base, pkt01);
+	q_last_base = rte_sched_port_qbase(port, q_last);
+	rte_sched_port_enqueue_qwa_prefetch0(port, q_last, q_last_base);
+
+	r00 = rte_sched_port_enqueue_qwa(port, q00, q00_base, pkt00);
+	r01 = rte_sched_port_enqueue_qwa(port, q01, q01_base, pkt01);
 	result += r00 + r01;
 
 	if (n_pkts & 1) {
-		r_last = rte_sched_port_enqueue_qwa(port, subport_last,
-					q_last,	q_last_base, pkt_last);
+		r_last = rte_sched_port_enqueue_qwa(port, q_last, q_last_base, pkt_last);
 		result += r_last;
 	}
 
@@ -2168,77 +1520,68 @@ rte_sched_port_enqueue(struct rte_sched_
 #ifndef RTE_SCHED_SUBPORT_TC_OV
 
 static inline void
-grinder_credits_update(struct rte_sched_port *port,
-	struct rte_sched_subport *subport, uint32_t pos)
+grinder_credits_update(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
+	struct rte_sched_subport *subport = grinder->subport;
 	struct rte_sched_pipe *pipe = grinder->pipe;
 	struct rte_sched_pipe_profile *params = grinder->pipe_params;
-	struct rte_sched_subport_profile *sp = grinder->subport_params;
 	uint64_t n_periods;
-	uint32_t i;
 
 	/* Subport TB */
-	n_periods = (port->time - subport->tb_time) / sp->tb_period;
-	subport->tb_credits += n_periods * sp->tb_credits_per_period;
-	subport->tb_credits = RTE_MIN(subport->tb_credits, sp->tb_size);
-	subport->tb_time += n_periods * sp->tb_period;
+	n_periods = (port->time - subport->tb_time) / subport->tb_period;
+	subport->tb_credits += n_periods * subport->tb_credits_per_period;
+	subport->tb_credits = rte_sched_min_val_2_u32(subport->tb_credits, subport->tb_size);
+	subport->tb_time += n_periods * subport->tb_period;
 
 	/* Pipe TB */
 	n_periods = (port->time - pipe->tb_time) / params->tb_period;
 	pipe->tb_credits += n_periods * params->tb_credits_per_period;
-	pipe->tb_credits = RTE_MIN(pipe->tb_credits, params->tb_size);
+	pipe->tb_credits = rte_sched_min_val_2_u32(pipe->tb_credits, params->tb_size);
 	pipe->tb_time += n_periods * params->tb_period;
 
 	/* Subport TCs */
 	if (unlikely(port->time >= subport->tc_time)) {
-		for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++)
-			subport->tc_credits[i] = sp->tc_credits_per_period[i];
-
-		subport->tc_time = port->time + sp->tc_period;
+		subport->tc_credits[0] = subport->tc_credits_per_period[0];
+		subport->tc_credits[1] = subport->tc_credits_per_period[1];
+		subport->tc_credits[2] = subport->tc_credits_per_period[2];
+		subport->tc_credits[3] = subport->tc_credits_per_period[3];
+		subport->tc_time = port->time + subport->tc_period;
 	}
 
 	/* Pipe TCs */
 	if (unlikely(port->time >= pipe->tc_time)) {
-		for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++)
-			pipe->tc_credits[i] = params->tc_credits_per_period[i];
-
+		pipe->tc_credits[0] = params->tc_credits_per_period[0];
+		pipe->tc_credits[1] = params->tc_credits_per_period[1];
+		pipe->tc_credits[2] = params->tc_credits_per_period[2];
+		pipe->tc_credits[3] = params->tc_credits_per_period[3];
 		pipe->tc_time = port->time + params->tc_period;
 	}
 }
 
 #else
 
-static inline uint64_t
-grinder_tc_ov_credits_update(struct rte_sched_port *port,
-	struct rte_sched_subport *subport, uint32_t pos)
+static inline uint32_t
+grinder_tc_ov_credits_update(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
-	struct rte_sched_subport_profile *sp = grinder->subport_params;
-	uint64_t tc_ov_consumption[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-	uint64_t tc_consumption = 0, tc_ov_consumption_max;
-	uint64_t tc_ov_wm = subport->tc_ov_wm;
-	uint32_t i;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
+	struct rte_sched_subport *subport = grinder->subport;
+	uint32_t tc_ov_consumption[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	uint32_t tc_ov_consumption_max;
+	uint32_t tc_ov_wm = subport->tc_ov_wm;
 
 	if (subport->tc_ov == 0)
 		return subport->tc_ov_wm_max;
 
-	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASS_BE; i++) {
-		tc_ov_consumption[i] = sp->tc_credits_per_period[i]
-					-  subport->tc_credits[i];
-		tc_consumption += tc_ov_consumption[i];
-	}
-
-	tc_ov_consumption[RTE_SCHED_TRAFFIC_CLASS_BE] =
-	sp->tc_credits_per_period[RTE_SCHED_TRAFFIC_CLASS_BE] -
-		subport->tc_credits[RTE_SCHED_TRAFFIC_CLASS_BE];
-
-	tc_ov_consumption_max =
-	sp->tc_credits_per_period[RTE_SCHED_TRAFFIC_CLASS_BE] -
-			tc_consumption;
+	tc_ov_consumption[0] = subport->tc_credits_per_period[0] - subport->tc_credits[0];
+	tc_ov_consumption[1] = subport->tc_credits_per_period[1] - subport->tc_credits[1];
+	tc_ov_consumption[2] = subport->tc_credits_per_period[2] - subport->tc_credits[2];
+	tc_ov_consumption[3] = subport->tc_credits_per_period[3] - subport->tc_credits[3];
 
-	if (tc_ov_consumption[RTE_SCHED_TRAFFIC_CLASS_BE] >
-		(tc_ov_consumption_max - port->mtu)) {
+	tc_ov_consumption_max = subport->tc_credits_per_period[3] -
+		(tc_ov_consumption[0] + tc_ov_consumption[1] + tc_ov_consumption[2]);
+
+	if (tc_ov_consumption[3] > (tc_ov_consumption_max - port->mtu)) {
 		tc_ov_wm  -= tc_ov_wm >> 7;
 		if (tc_ov_wm < subport->tc_ov_wm_min)
 			tc_ov_wm = subport->tc_ov_wm_min;
@@ -2254,44 +1597,45 @@ grinder_tc_ov_credits_update(struct rte_
 }
 
 static inline void
-grinder_credits_update(struct rte_sched_port *port,
-	struct rte_sched_subport *subport, uint32_t pos)
+grinder_credits_update(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
+	struct rte_sched_subport *subport = grinder->subport;
 	struct rte_sched_pipe *pipe = grinder->pipe;
 	struct rte_sched_pipe_profile *params = grinder->pipe_params;
-	struct rte_sched_subport_profile *sp = grinder->subport_params;
 	uint64_t n_periods;
-	uint32_t i;
 
 	/* Subport TB */
-	n_periods = (port->time - subport->tb_time) / sp->tb_period;
-	subport->tb_credits += n_periods * sp->tb_credits_per_period;
-	subport->tb_credits = RTE_MIN(subport->tb_credits, sp->tb_size);
-	subport->tb_time += n_periods * sp->tb_period;
+	n_periods = (port->time - subport->tb_time) / subport->tb_period;
+	subport->tb_credits += n_periods * subport->tb_credits_per_period;
+	subport->tb_credits = rte_sched_min_val_2_u32(subport->tb_credits, subport->tb_size);
+	subport->tb_time += n_periods * subport->tb_period;
 
 	/* Pipe TB */
 	n_periods = (port->time - pipe->tb_time) / params->tb_period;
 	pipe->tb_credits += n_periods * params->tb_credits_per_period;
-	pipe->tb_credits = RTE_MIN(pipe->tb_credits, params->tb_size);
+	pipe->tb_credits = rte_sched_min_val_2_u32(pipe->tb_credits, params->tb_size);
 	pipe->tb_time += n_periods * params->tb_period;
 
 	/* Subport TCs */
 	if (unlikely(port->time >= subport->tc_time)) {
-		subport->tc_ov_wm =
-			grinder_tc_ov_credits_update(port, subport, pos);
+		subport->tc_ov_wm = grinder_tc_ov_credits_update(port, pos);
 
-		for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++)
-			subport->tc_credits[i] = sp->tc_credits_per_period[i];
+		subport->tc_credits[0] = subport->tc_credits_per_period[0];
+		subport->tc_credits[1] = subport->tc_credits_per_period[1];
+		subport->tc_credits[2] = subport->tc_credits_per_period[2];
+		subport->tc_credits[3] = subport->tc_credits_per_period[3];
 
-		subport->tc_time = port->time + sp->tc_period;
+		subport->tc_time = port->time + subport->tc_period;
 		subport->tc_ov_period_id++;
 	}
 
 	/* Pipe TCs */
 	if (unlikely(port->time >= pipe->tc_time)) {
-		for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++)
-			pipe->tc_credits[i] = params->tc_credits_per_period[i];
+		pipe->tc_credits[0] = params->tc_credits_per_period[0];
+		pipe->tc_credits[1] = params->tc_credits_per_period[1];
+		pipe->tc_credits[2] = params->tc_credits_per_period[2];
+		pipe->tc_credits[3] = params->tc_credits_per_period[3];
 		pipe->tc_time = port->time + params->tc_period;
 	}
 
@@ -2309,18 +1653,18 @@ grinder_credits_update(struct rte_sched_
 #ifndef RTE_SCHED_SUBPORT_TC_OV
 
 static inline int
-grinder_credits_check(struct rte_sched_port *port,
-	struct rte_sched_subport *subport, uint32_t pos)
+grinder_credits_check(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
+	struct rte_sched_subport *subport = grinder->subport;
 	struct rte_sched_pipe *pipe = grinder->pipe;
 	struct rte_mbuf *pkt = grinder->pkt;
 	uint32_t tc_index = grinder->tc_index;
-	uint64_t pkt_len = pkt->pkt_len + port->frame_overhead;
-	uint64_t subport_tb_credits = subport->tb_credits;
-	uint64_t subport_tc_credits = subport->tc_credits[tc_index];
-	uint64_t pipe_tb_credits = pipe->tb_credits;
-	uint64_t pipe_tc_credits = pipe->tc_credits[tc_index];
+	uint32_t pkt_len = pkt->pkt_len + port->frame_overhead;
+	uint32_t subport_tb_credits = subport->tb_credits;
+	uint32_t subport_tc_credits = subport->tc_credits[tc_index];
+	uint32_t pipe_tb_credits = pipe->tb_credits;
+	uint32_t pipe_tc_credits = pipe->tc_credits[tc_index];
 	int enough_credits;
 
 	/* Check queue credits */
@@ -2344,31 +1688,23 @@ grinder_credits_check(struct rte_sched_p
 #else
 
 static inline int
-grinder_credits_check(struct rte_sched_port *port,
-	struct rte_sched_subport *subport, uint32_t pos)
+grinder_credits_check(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
+	struct rte_sched_subport *subport = grinder->subport;
 	struct rte_sched_pipe *pipe = grinder->pipe;
 	struct rte_mbuf *pkt = grinder->pkt;
 	uint32_t tc_index = grinder->tc_index;
-	uint64_t pkt_len = pkt->pkt_len + port->frame_overhead;
-	uint64_t subport_tb_credits = subport->tb_credits;
-	uint64_t subport_tc_credits = subport->tc_credits[tc_index];
-	uint64_t pipe_tb_credits = pipe->tb_credits;
-	uint64_t pipe_tc_credits = pipe->tc_credits[tc_index];
-	uint64_t pipe_tc_ov_mask1[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-	uint64_t pipe_tc_ov_mask2[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE] = {0};
-	uint64_t pipe_tc_ov_credits;
-	uint32_t i;
+	uint32_t pkt_len = pkt->pkt_len + port->frame_overhead;
+	uint32_t subport_tb_credits = subport->tb_credits;
+	uint32_t subport_tc_credits = subport->tc_credits[tc_index];
+	uint32_t pipe_tb_credits = pipe->tb_credits;
+	uint32_t pipe_tc_credits = pipe->tc_credits[tc_index];
+	uint32_t pipe_tc_ov_mask1[] = {UINT32_MAX, UINT32_MAX, UINT32_MAX, pipe->tc_ov_credits};
+	uint32_t pipe_tc_ov_mask2[] = {0, 0, 0, UINT32_MAX};
+	uint32_t pipe_tc_ov_credits = pipe_tc_ov_mask1[tc_index];
 	int enough_credits;
 
-	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE; i++)
-		pipe_tc_ov_mask1[i] = ~0LLU;
-
-	pipe_tc_ov_mask1[RTE_SCHED_TRAFFIC_CLASS_BE] = pipe->tc_ov_credits;
-	pipe_tc_ov_mask2[RTE_SCHED_TRAFFIC_CLASS_BE] = ~0LLU;
-	pipe_tc_ov_credits = pipe_tc_ov_mask1[tc_index];
-
 	/* Check pipe and subport credits */
 	enough_credits = (pkt_len <= subport_tb_credits) &&
 		(pkt_len <= subport_tc_credits) &&
@@ -2393,16 +1729,14 @@ grinder_credits_check(struct rte_sched_p
 
 
 static inline int
-grinder_schedule(struct rte_sched_port *port,
-	struct rte_sched_subport *subport, uint32_t pos)
+grinder_schedule(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
 	struct rte_sched_queue *queue = grinder->queue[grinder->qpos];
 	struct rte_mbuf *pkt = grinder->pkt;
 	uint32_t pkt_len = pkt->pkt_len + port->frame_overhead;
-	uint32_t be_tc_active;
 
-	if (!grinder_credits_check(port, subport, pos))
+	if (!grinder_credits_check(port, pos))
 		return 0;
 
 	/* Advance port time */
@@ -2411,23 +1745,18 @@ grinder_schedule(struct rte_sched_port *
 	/* Send packet */
 	port->pkts_out[port->n_pkts_out++] = pkt;
 	queue->qr++;
-
-	be_tc_active = (grinder->tc_index == RTE_SCHED_TRAFFIC_CLASS_BE) ? ~0x0 : 0x0;
-	grinder->wrr_tokens[grinder->qpos] +=
-		(pkt_len * grinder->wrr_cost[grinder->qpos]) & be_tc_active;
-
+	grinder->wrr_tokens[grinder->qpos] += pkt_len * grinder->wrr_cost[grinder->qpos];
 	if (queue->qr == queue->qw) {
 		uint32_t qindex = grinder->qindex[grinder->qpos];
 
-		rte_bitmap_clear(subport->bmp, qindex);
+		rte_bitmap_clear(port->bmp, qindex);
 		grinder->qmask &= ~(1 << grinder->qpos);
-		if (be_tc_active)
-			grinder->wrr_mask[grinder->qpos] = 0;
-		rte_sched_port_set_queue_empty_timestamp(port, subport, qindex);
+		grinder->wrr_mask[grinder->qpos] = 0;
+		rte_sched_port_set_queue_empty_timestamp(port, qindex);
 	}
 
 	/* Reset pipe loop detection */
-	subport->pipe_loop = RTE_SCHED_PIPE_INVALID;
+	port->pipe_loop = RTE_SCHED_PIPE_INVALID;
 	grinder->productive = 1;
 
 	return 1;
@@ -2436,13 +1765,13 @@ grinder_schedule(struct rte_sched_port *
 #ifdef SCHED_VECTOR_SSE4
 
 static inline int
-grinder_pipe_exists(struct rte_sched_subport *subport, uint32_t base_pipe)
+grinder_pipe_exists(struct rte_sched_port *port, uint32_t base_pipe)
 {
 	__m128i index = _mm_set1_epi32(base_pipe);
-	__m128i pipes = _mm_load_si128((__m128i *)subport->grinder_base_bmp_pos);
+	__m128i pipes = _mm_load_si128((__m128i *)port->grinder_base_bmp_pos);
 	__m128i res = _mm_cmpeq_epi32(pipes, index);
 
-	pipes = _mm_load_si128((__m128i *)(subport->grinder_base_bmp_pos + 4));
+	pipes = _mm_load_si128((__m128i *)(port->grinder_base_bmp_pos + 4));
 	pipes = _mm_cmpeq_epi32(pipes, index);
 	res = _mm_or_si128(res, pipes);
 
@@ -2455,10 +1784,10 @@ grinder_pipe_exists(struct rte_sched_sub
 #elif defined(SCHED_VECTOR_NEON)
 
 static inline int
-grinder_pipe_exists(struct rte_sched_subport *subport, uint32_t base_pipe)
+grinder_pipe_exists(struct rte_sched_port *port, uint32_t base_pipe)
 {
 	uint32x4_t index, pipes;
-	uint32_t *pos = (uint32_t *)subport->grinder_base_bmp_pos;
+	uint32_t *pos = (uint32_t *)port->grinder_base_bmp_pos;
 
 	index = vmovq_n_u32(base_pipe);
 	pipes = vld1q_u32(pos);
@@ -2475,12 +1804,12 @@ grinder_pipe_exists(struct rte_sched_sub
 #else
 
 static inline int
-grinder_pipe_exists(struct rte_sched_subport *subport, uint32_t base_pipe)
+grinder_pipe_exists(struct rte_sched_port *port, uint32_t base_pipe)
 {
 	uint32_t i;
 
 	for (i = 0; i < RTE_SCHED_PORT_N_GRINDERS; i++) {
-		if (subport->grinder_base_bmp_pos[i] == base_pipe)
+		if (port->grinder_base_bmp_pos[i] == base_pipe)
 			return 1;
 	}
 
@@ -2490,10 +1819,9 @@ grinder_pipe_exists(struct rte_sched_sub
 #endif /* RTE_SCHED_OPTIMIZATIONS */
 
 static inline void
-grinder_pcache_populate(struct rte_sched_subport *subport,
-	uint32_t pos, uint32_t bmp_pos, uint64_t bmp_slab)
+grinder_pcache_populate(struct rte_sched_port *port, uint32_t pos, uint32_t bmp_pos, uint64_t bmp_slab)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
 	uint16_t w[4];
 
 	grinder->pcache_w = 0;
@@ -2522,34 +1850,40 @@ grinder_pcache_populate(struct rte_sched
 }
 
 static inline void
-grinder_tccache_populate(struct rte_sched_subport *subport,
-	uint32_t pos, uint32_t qindex, uint16_t qmask)
+grinder_tccache_populate(struct rte_sched_port *port, uint32_t pos, uint32_t qindex, uint16_t qmask)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
-	uint8_t b, i;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
+	uint8_t b[4];
 
 	grinder->tccache_w = 0;
 	grinder->tccache_r = 0;
 
-	for (i = 0; i < RTE_SCHED_TRAFFIC_CLASS_BE; i++) {
-		b = (uint8_t) ((qmask >> i) & 0x1);
-		grinder->tccache_qmask[grinder->tccache_w] = b;
-		grinder->tccache_qindex[grinder->tccache_w] = qindex + i;
-		grinder->tccache_w += (b != 0);
-	}
-
-	b = (uint8_t) (qmask >> (RTE_SCHED_TRAFFIC_CLASS_BE));
-	grinder->tccache_qmask[grinder->tccache_w] = b;
-	grinder->tccache_qindex[grinder->tccache_w] = qindex +
-		RTE_SCHED_TRAFFIC_CLASS_BE;
-	grinder->tccache_w += (b != 0);
+	b[0] = (uint8_t) (qmask & 0xF);
+	b[1] = (uint8_t) ((qmask >> 4) & 0xF);
+	b[2] = (uint8_t) ((qmask >> 8) & 0xF);
+	b[3] = (uint8_t) ((qmask >> 12) & 0xF);
+
+	grinder->tccache_qmask[grinder->tccache_w] = b[0];
+	grinder->tccache_qindex[grinder->tccache_w] = qindex;
+	grinder->tccache_w += (b[0] != 0);
+
+	grinder->tccache_qmask[grinder->tccache_w] = b[1];
+	grinder->tccache_qindex[grinder->tccache_w] = qindex + 4;
+	grinder->tccache_w += (b[1] != 0);
+
+	grinder->tccache_qmask[grinder->tccache_w] = b[2];
+	grinder->tccache_qindex[grinder->tccache_w] = qindex + 8;
+	grinder->tccache_w += (b[2] != 0);
+
+	grinder->tccache_qmask[grinder->tccache_w] = b[3];
+	grinder->tccache_qindex[grinder->tccache_w] = qindex + 12;
+	grinder->tccache_w += (b[3] != 0);
 }
 
 static inline int
-grinder_next_tc(struct rte_sched_port *port,
-	struct rte_sched_subport *subport, uint32_t pos)
+grinder_next_tc(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
 	struct rte_mbuf **qbase;
 	uint32_t qindex;
 	uint16_t qsize;
@@ -2558,46 +1892,36 @@ grinder_next_tc(struct rte_sched_port *p
 		return 0;
 
 	qindex = grinder->tccache_qindex[grinder->tccache_r];
-	qbase = rte_sched_subport_pipe_qbase(subport, qindex);
-	qsize = rte_sched_subport_pipe_qsize(port, subport, qindex);
+	qbase = rte_sched_port_qbase(port, qindex);
+	qsize = rte_sched_port_qsize(port, qindex);
 
-	grinder->tc_index = rte_sched_port_pipe_tc(port, qindex);
+	grinder->tc_index = (qindex >> 2) & 0x3;
 	grinder->qmask = grinder->tccache_qmask[grinder->tccache_r];
 	grinder->qsize = qsize;
 
-	if (grinder->tc_index < RTE_SCHED_TRAFFIC_CLASS_BE) {
-		grinder->queue[0] = subport->queue + qindex;
-		grinder->qbase[0] = qbase;
-		grinder->qindex[0] = qindex;
-		grinder->tccache_r++;
-
-		return 1;
-	}
+	grinder->qindex[0] = qindex;
+	grinder->qindex[1] = qindex + 1;
+	grinder->qindex[2] = qindex + 2;
+	grinder->qindex[3] = qindex + 3;
 
-	grinder->queue[0] = subport->queue + qindex;
-	grinder->queue[1] = subport->queue + qindex + 1;
-	grinder->queue[2] = subport->queue + qindex + 2;
-	grinder->queue[3] = subport->queue + qindex + 3;
+	grinder->queue[0] = port->queue + qindex;
+	grinder->queue[1] = port->queue + qindex + 1;
+	grinder->queue[2] = port->queue + qindex + 2;
+	grinder->queue[3] = port->queue + qindex + 3;
 
 	grinder->qbase[0] = qbase;
 	grinder->qbase[1] = qbase + qsize;
 	grinder->qbase[2] = qbase + 2 * qsize;
 	grinder->qbase[3] = qbase + 3 * qsize;
 
-	grinder->qindex[0] = qindex;
-	grinder->qindex[1] = qindex + 1;
-	grinder->qindex[2] = qindex + 2;
-	grinder->qindex[3] = qindex + 3;
-
 	grinder->tccache_r++;
 	return 1;
 }
 
 static inline int
-grinder_next_pipe(struct rte_sched_port *port,
-	struct rte_sched_subport *subport, uint32_t pos)
+grinder_next_pipe(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
 	uint32_t pipe_qindex;
 	uint16_t pipe_qmask;
 
@@ -2610,22 +1934,22 @@ grinder_next_pipe(struct rte_sched_port
 		uint32_t bmp_pos = 0;
 
 		/* Get another non-empty pipe group */
-		if (unlikely(rte_bitmap_scan(subport->bmp, &bmp_pos, &bmp_slab) <= 0))
+		if (unlikely(rte_bitmap_scan(port->bmp, &bmp_pos, &bmp_slab) <= 0))
 			return 0;
 
 #ifdef RTE_SCHED_DEBUG
-		debug_check_queue_slab(subport, bmp_pos, bmp_slab);
+		debug_check_queue_slab(port, bmp_pos, bmp_slab);
 #endif
 
 		/* Return if pipe group already in one of the other grinders */
-		subport->grinder_base_bmp_pos[pos] = RTE_SCHED_BMP_POS_INVALID;
-		if (unlikely(grinder_pipe_exists(subport, bmp_pos)))
+		port->grinder_base_bmp_pos[pos] = RTE_SCHED_BMP_POS_INVALID;
+		if (unlikely(grinder_pipe_exists(port, bmp_pos)))
 			return 0;
 
-		subport->grinder_base_bmp_pos[pos] = bmp_pos;
+		port->grinder_base_bmp_pos[pos] = bmp_pos;
 
 		/* Install new pipe group into grinder's pipe cache */
-		grinder_pcache_populate(subport, pos, bmp_pos, bmp_slab);
+		grinder_pcache_populate(port, pos, bmp_pos, bmp_slab);
 
 		pipe_qmask = grinder->pcache_qmask[0];
 		pipe_qindex = grinder->pcache_qindex[0];
@@ -2634,18 +1958,18 @@ grinder_next_pipe(struct rte_sched_port
 
 	/* Install new pipe in the grinder */
 	grinder->pindex = pipe_qindex >> 4;
-	grinder->subport = subport;
-	grinder->pipe = subport->pipe + grinder->pindex;
+	grinder->subport = port->subport + (grinder->pindex / port->n_pipes_per_subport);
+	grinder->pipe = port->pipe + grinder->pindex;
 	grinder->pipe_params = NULL; /* to be set after the pipe structure is prefetched */
 	grinder->productive = 0;
 
-	grinder_tccache_populate(subport, pos, pipe_qindex, pipe_qmask);
-	grinder_next_tc(port, subport, pos);
+	grinder_tccache_populate(port, pos, pipe_qindex, pipe_qmask);
+	grinder_next_tc(port, pos);
 
 	/* Check for pipe exhaustion */
-	if (grinder->pindex == subport->pipe_loop) {
-		subport->pipe_exhaustion = 1;
-		subport->pipe_loop = RTE_SCHED_PIPE_INVALID;
+	if (grinder->pindex == port->pipe_loop) {
+		port->pipe_exhaustion = 1;
+		port->pipe_loop = RTE_SCHED_PIPE_INVALID;
 	}
 
 	return 1;
@@ -2653,57 +1977,57 @@ grinder_next_pipe(struct rte_sched_port
 
 
 static inline void
-grinder_wrr_load(struct rte_sched_subport *subport, uint32_t pos)
+grinder_wrr_load(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
 	struct rte_sched_pipe *pipe = grinder->pipe;
 	struct rte_sched_pipe_profile *pipe_params = grinder->pipe_params;
+	uint32_t tc_index = grinder->tc_index;
 	uint32_t qmask = grinder->qmask;
+	uint32_t qindex;
 
-	grinder->wrr_tokens[0] =
-		((uint16_t) pipe->wrr_tokens[0]) << RTE_SCHED_WRR_SHIFT;
-	grinder->wrr_tokens[1] =
-		((uint16_t) pipe->wrr_tokens[1]) << RTE_SCHED_WRR_SHIFT;
-	grinder->wrr_tokens[2] =
-		((uint16_t) pipe->wrr_tokens[2]) << RTE_SCHED_WRR_SHIFT;
-	grinder->wrr_tokens[3] =
-		((uint16_t) pipe->wrr_tokens[3]) << RTE_SCHED_WRR_SHIFT;
+	qindex = tc_index * 4;
+
+	grinder->wrr_tokens[0] = ((uint16_t) pipe->wrr_tokens[qindex]) << RTE_SCHED_WRR_SHIFT;
+	grinder->wrr_tokens[1] = ((uint16_t) pipe->wrr_tokens[qindex + 1]) << RTE_SCHED_WRR_SHIFT;
+	grinder->wrr_tokens[2] = ((uint16_t) pipe->wrr_tokens[qindex + 2]) << RTE_SCHED_WRR_SHIFT;
+	grinder->wrr_tokens[3] = ((uint16_t) pipe->wrr_tokens[qindex + 3]) << RTE_SCHED_WRR_SHIFT;
 
 	grinder->wrr_mask[0] = (qmask & 0x1) * 0xFFFF;
 	grinder->wrr_mask[1] = ((qmask >> 1) & 0x1) * 0xFFFF;
 	grinder->wrr_mask[2] = ((qmask >> 2) & 0x1) * 0xFFFF;
 	grinder->wrr_mask[3] = ((qmask >> 3) & 0x1) * 0xFFFF;
 
-	grinder->wrr_cost[0] = pipe_params->wrr_cost[0];
-	grinder->wrr_cost[1] = pipe_params->wrr_cost[1];
-	grinder->wrr_cost[2] = pipe_params->wrr_cost[2];
-	grinder->wrr_cost[3] = pipe_params->wrr_cost[3];
+	grinder->wrr_cost[0] = pipe_params->wrr_cost[qindex];
+	grinder->wrr_cost[1] = pipe_params->wrr_cost[qindex + 1];
+	grinder->wrr_cost[2] = pipe_params->wrr_cost[qindex + 2];
+	grinder->wrr_cost[3] = pipe_params->wrr_cost[qindex + 3];
 }
 
 static inline void
-grinder_wrr_store(struct rte_sched_subport *subport, uint32_t pos)
+grinder_wrr_store(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
 	struct rte_sched_pipe *pipe = grinder->pipe;
+	uint32_t tc_index = grinder->tc_index;
+	uint32_t qindex;
+
+	qindex = tc_index * 4;
 
-	pipe->wrr_tokens[0] =
-			(grinder->wrr_tokens[0] & grinder->wrr_mask[0]) >>
-				RTE_SCHED_WRR_SHIFT;
-	pipe->wrr_tokens[1] =
-			(grinder->wrr_tokens[1] & grinder->wrr_mask[1]) >>
-				RTE_SCHED_WRR_SHIFT;
-	pipe->wrr_tokens[2] =
-			(grinder->wrr_tokens[2] & grinder->wrr_mask[2]) >>
-				RTE_SCHED_WRR_SHIFT;
-	pipe->wrr_tokens[3] =
-			(grinder->wrr_tokens[3] & grinder->wrr_mask[3]) >>
-				RTE_SCHED_WRR_SHIFT;
+	pipe->wrr_tokens[qindex] = (grinder->wrr_tokens[0] & grinder->wrr_mask[0])
+		>> RTE_SCHED_WRR_SHIFT;
+	pipe->wrr_tokens[qindex + 1] = (grinder->wrr_tokens[1] & grinder->wrr_mask[1])
+		>> RTE_SCHED_WRR_SHIFT;
+	pipe->wrr_tokens[qindex + 2] = (grinder->wrr_tokens[2] & grinder->wrr_mask[2])
+		>> RTE_SCHED_WRR_SHIFT;
+	pipe->wrr_tokens[qindex + 3] = (grinder->wrr_tokens[3] & grinder->wrr_mask[3])
+		>> RTE_SCHED_WRR_SHIFT;
 }
 
 static inline void
-grinder_wrr(struct rte_sched_subport *subport, uint32_t pos)
+grinder_wrr(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
 	uint16_t wrr_tokens_min;
 
 	grinder->wrr_tokens[0] |= ~grinder->wrr_mask[0];
@@ -2721,33 +2045,24 @@ grinder_wrr(struct rte_sched_subport *su
 }
 
 
-#define grinder_evict(subport, pos)
+#define grinder_evict(port, pos)
 
 static inline void
-grinder_prefetch_pipe(struct rte_sched_subport *subport, uint32_t pos)
+grinder_prefetch_pipe(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
 
 	rte_prefetch0(grinder->pipe);
 	rte_prefetch0(grinder->queue[0]);
 }
 
 static inline void
-grinder_prefetch_tc_queue_arrays(struct rte_sched_subport *subport, uint32_t pos)
+grinder_prefetch_tc_queue_arrays(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
-	uint16_t qsize, qr[RTE_SCHED_MAX_QUEUES_PER_TC];
+	struct rte_sched_grinder *grinder = port->grinder + pos;
+	uint16_t qsize, qr[4];
 
 	qsize = grinder->qsize;
-	grinder->qpos = 0;
-
-	if (grinder->tc_index < RTE_SCHED_TRAFFIC_CLASS_BE) {
-		qr[0] = grinder->queue[0]->qr & (qsize - 1);
-
-		rte_prefetch0(grinder->qbase[0] + qr[0]);
-		return;
-	}
-
 	qr[0] = grinder->queue[0]->qr & (qsize - 1);
 	qr[1] = grinder->queue[1]->qr & (qsize - 1);
 	qr[2] = grinder->queue[2]->qr & (qsize - 1);
@@ -2756,17 +2071,17 @@ grinder_prefetch_tc_queue_arrays(struct
 	rte_prefetch0(grinder->qbase[0] + qr[0]);
 	rte_prefetch0(grinder->qbase[1] + qr[1]);
 
-	grinder_wrr_load(subport, pos);
-	grinder_wrr(subport, pos);
+	grinder_wrr_load(port, pos);
+	grinder_wrr(port, pos);
 
 	rte_prefetch0(grinder->qbase[2] + qr[2]);
 	rte_prefetch0(grinder->qbase[3] + qr[3]);
 }
 
 static inline void
-grinder_prefetch_mbuf(struct rte_sched_subport *subport, uint32_t pos)
+grinder_prefetch_mbuf(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
 	uint32_t qpos = grinder->qpos;
 	struct rte_mbuf **qbase = grinder->qbase[qpos];
 	uint16_t qsize = grinder->qsize;
@@ -2783,17 +2098,16 @@ grinder_prefetch_mbuf(struct rte_sched_s
 }
 
 static inline uint32_t
-grinder_handle(struct rte_sched_port *port,
-	struct rte_sched_subport *subport, uint32_t pos)
+grinder_handle(struct rte_sched_port *port, uint32_t pos)
 {
-	struct rte_sched_grinder *grinder = subport->grinder + pos;
+	struct rte_sched_grinder *grinder = port->grinder + pos;
 
 	switch (grinder->state) {
 	case e_GRINDER_PREFETCH_PIPE:
 	{
-		if (grinder_next_pipe(port, subport, pos)) {
-			grinder_prefetch_pipe(subport, pos);
-			subport->busy_grinders++;
+		if (grinder_next_pipe(port, pos)) {
+			grinder_prefetch_pipe(port, pos);
+			port->busy_grinders++;
 
 			grinder->state = e_GRINDER_PREFETCH_TC_QUEUE_ARRAYS;
 			return 0;
@@ -2806,12 +2120,9 @@ grinder_handle(struct rte_sched_port *po
 	{
 		struct rte_sched_pipe *pipe = grinder->pipe;
 
-		grinder->pipe_params = subport->pipe_profiles + pipe->profile;
-		grinder->subport_params = port->subport_profiles +
-						subport->profile;
-
-		grinder_prefetch_tc_queue_arrays(subport, pos);
-		grinder_credits_update(port, subport, pos);
+		grinder->pipe_params = port->pipe_profiles + pipe->profile;
+		grinder_prefetch_tc_queue_arrays(port, pos);
+		grinder_credits_update(port, pos);
 
 		grinder->state = e_GRINDER_PREFETCH_MBUF;
 		return 0;
@@ -2819,7 +2130,7 @@ grinder_handle(struct rte_sched_port *po
 
 	case e_GRINDER_PREFETCH_MBUF:
 	{
-		grinder_prefetch_mbuf(subport, pos);
+		grinder_prefetch_mbuf(port, pos);
 
 		grinder->state = e_GRINDER_READ_MBUF;
 		return 0;
@@ -2827,49 +2138,43 @@ grinder_handle(struct rte_sched_port *po
 
 	case e_GRINDER_READ_MBUF:
 	{
-		uint32_t wrr_active, result = 0;
+		uint32_t result = 0;
 
-		result = grinder_schedule(port, subport, pos);
-
-		wrr_active = (grinder->tc_index == RTE_SCHED_TRAFFIC_CLASS_BE);
+		result = grinder_schedule(port, pos);
 
 		/* Look for next packet within the same TC */
 		if (result && grinder->qmask) {
-			if (wrr_active)
-				grinder_wrr(subport, pos);
-
-			grinder_prefetch_mbuf(subport, pos);
+			grinder_wrr(port, pos);
+			grinder_prefetch_mbuf(port, pos);
 
 			return 1;
 		}
-
-		if (wrr_active)
-			grinder_wrr_store(subport, pos);
+		grinder_wrr_store(port, pos);
 
 		/* Look for another active TC within same pipe */
-		if (grinder_next_tc(port, subport, pos)) {
-			grinder_prefetch_tc_queue_arrays(subport, pos);
+		if (grinder_next_tc(port, pos)) {
+			grinder_prefetch_tc_queue_arrays(port, pos);
 
 			grinder->state = e_GRINDER_PREFETCH_MBUF;
 			return result;
 		}
 
 		if (grinder->productive == 0 &&
-		    subport->pipe_loop == RTE_SCHED_PIPE_INVALID)
-			subport->pipe_loop = grinder->pindex;
+		    port->pipe_loop == RTE_SCHED_PIPE_INVALID)
+			port->pipe_loop = grinder->pindex;
 
-		grinder_evict(subport, pos);
+		grinder_evict(port, pos);
 
 		/* Look for another active pipe */
-		if (grinder_next_pipe(port, subport, pos)) {
-			grinder_prefetch_pipe(subport, pos);
+		if (grinder_next_pipe(port, pos)) {
+			grinder_prefetch_pipe(port, pos);
 
 			grinder->state = e_GRINDER_PREFETCH_TC_QUEUE_ARRAYS;
 			return result;
 		}
 
 		/* No active pipe found */
-		subport->busy_grinders--;
+		port->busy_grinders--;
 
 		grinder->state = e_GRINDER_PREFETCH_PIPE;
 		return result;
@@ -2885,41 +2190,34 @@ static inline void
 rte_sched_port_time_resync(struct rte_sched_port *port)
 {
 	uint64_t cycles = rte_get_tsc_cycles();
-	uint64_t cycles_diff;
+	uint64_t cycles_diff = cycles - port->time_cpu_cycles;
 	uint64_t bytes_diff;
-	uint32_t i;
 
-	if (cycles < port->time_cpu_cycles)
-		port->time_cpu_cycles = 0;
-
-	cycles_diff = cycles - port->time_cpu_cycles;
 	/* Compute elapsed time in bytes */
 	bytes_diff = rte_reciprocal_divide(cycles_diff << RTE_SCHED_TIME_SHIFT,
 					   port->inv_cycles_per_byte);
 
 	/* Advance port time */
-	port->time_cpu_cycles +=
-		(bytes_diff * port->cycles_per_byte) >> RTE_SCHED_TIME_SHIFT;
+	port->time_cpu_cycles = cycles;
 	port->time_cpu_bytes += bytes_diff;
 	if (port->time < port->time_cpu_bytes)
 		port->time = port->time_cpu_bytes;
 
 	/* Reset pipe loop detection */
-	for (i = 0; i < port->n_subports_per_port; i++)
-		port->subports[i]->pipe_loop = RTE_SCHED_PIPE_INVALID;
+	port->pipe_loop = RTE_SCHED_PIPE_INVALID;
 }
 
 static inline int
-rte_sched_port_exceptions(struct rte_sched_subport *subport, int second_pass)
+rte_sched_port_exceptions(struct rte_sched_port *port, int second_pass)
 {
 	int exceptions;
 
 	/* Check if any exception flag is set */
-	exceptions = (second_pass && subport->busy_grinders == 0) ||
-		(subport->pipe_exhaustion == 1);
+	exceptions = (second_pass && port->busy_grinders == 0) ||
+		(port->pipe_exhaustion == 1);
 
 	/* Clear exception flags */
-	subport->pipe_exhaustion = 0;
+	port->pipe_exhaustion = 0;
 
 	return exceptions;
 }
@@ -2927,9 +2225,7 @@ rte_sched_port_exceptions(struct rte_sch
 int
 rte_sched_port_dequeue(struct rte_sched_port *port, struct rte_mbuf **pkts, uint32_t n_pkts)
 {
-	struct rte_sched_subport *subport;
-	uint32_t subport_id = port->subport_id;
-	uint32_t i, n_subports = 0, count;
+	uint32_t i, count;
 
 	port->pkts_out = pkts;
 	port->n_pkts_out = 0;
@@ -2938,32 +2234,9 @@ rte_sched_port_dequeue(struct rte_sched_
 
 	/* Take each queue in the grinder one step further */
 	for (i = 0, count = 0; ; i++)  {
-		subport = port->subports[subport_id];
-
-		count += grinder_handle(port, subport,
-				i & (RTE_SCHED_PORT_N_GRINDERS - 1));
-
-		if (count == n_pkts) {
-			subport_id++;
-
-			if (subport_id == port->n_subports_per_port)
-				subport_id = 0;
-
-			port->subport_id = subport_id;
-			break;
-		}
-
-		if (rte_sched_port_exceptions(subport, i >= RTE_SCHED_PORT_N_GRINDERS)) {
-			i = 0;
-			subport_id++;
-			n_subports++;
-		}
-
-		if (subport_id == port->n_subports_per_port)
-			subport_id = 0;
-
-		if (n_subports == port->n_subports_per_port) {
-			port->subport_id = subport_id;
+		count += grinder_handle(port, i & (RTE_SCHED_PORT_N_GRINDERS - 1));
+		if ((count == n_pkts) ||
+		    rte_sched_port_exceptions(port, i >= RTE_SCHED_PORT_N_GRINDERS)) {
 			break;
 		}
 	}
--- a/lib/librte_sched/rte_sched.h
+++ b/lib/librte_sched/rte_sched.h
@@ -52,7 +52,7 @@ extern "C" {
  *	    multiple connections of same traffic class belonging to
  *	    the same user;
  *           - Weighted Round Robin (WRR) is used to service the
- *	    queues within same pipe lowest priority traffic class (best-effort).
+ *	    queues within same pipe traffic class.
  *
  */
 
@@ -66,33 +66,25 @@ extern "C" {
 #include "rte_red.h"
 #endif
 
-/** Maximum number of queues per pipe.
- * Note that the multiple queues (power of 2) can only be assigned to
- * lowest priority (best-effort) traffic class. Other higher priority traffic
- * classes can only have one queue.
- * Can not change.
- *
- * @see struct rte_sched_port_params
+/** Number of traffic classes per pipe (as well as subport).
+ * Cannot be changed.
  */
-#define RTE_SCHED_QUEUES_PER_PIPE    16
+#define RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE    4
 
-/** Number of WRR queues for best-effort traffic class per pipe.
- *
- * @see struct rte_sched_pipe_params
- */
-#define RTE_SCHED_BE_QUEUES_PER_PIPE    4
+/** Number of queues per pipe traffic class. Cannot be changed. */
+#define RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS    4
 
-/** Number of traffic classes per pipe (as well as subport).
- * @see struct rte_sched_subport_params
- * @see struct rte_sched_pipe_params
- */
-#define RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE    \
-(RTE_SCHED_QUEUES_PER_PIPE - RTE_SCHED_BE_QUEUES_PER_PIPE + 1)
+/** Number of queues per pipe. */
+#define RTE_SCHED_QUEUES_PER_PIPE             \
+	(RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE *     \
+	RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS)
 
-/** Best-effort traffic class ID
- * Can not change.
+/** Maximum number of pipe profiles that can be defined per port.
+ * Compile-time configurable.
  */
-#define RTE_SCHED_TRAFFIC_CLASS_BE    (RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE - 1)
+#ifndef RTE_SCHED_PIPE_PROFILES_PER_PORT
+#define RTE_SCHED_PIPE_PROFILES_PER_PORT      256
+#endif
 
 /*
  * Ethernet framing overhead. Overhead fields per Ethernet frame:
@@ -103,15 +95,13 @@ extern "C" {
  *
  * The FCS is considered overhead only if not included in the packet
  * length (field pkt_len of struct rte_mbuf).
- *
- * @see struct rte_sched_port_params
  */
 #ifndef RTE_SCHED_FRAME_OVERHEAD_DEFAULT
 #define RTE_SCHED_FRAME_OVERHEAD_DEFAULT      24
 #endif
 
 /*
- * Pipe configuration parameters. The period and credits_per_period
+ * Subport configuration parameters. The period and credits_per_period
  * parameters are measured in bytes, with one byte meaning the time
  * duration associated with the transmission of one byte on the
  * physical medium of the output port, with pipe or pipe traffic class
@@ -119,28 +109,40 @@ extern "C" {
  * credits_per_period divided by period. One credit represents one
  * byte.
  */
-struct rte_sched_pipe_params {
-	/** Token bucket rate (measured in bytes per second) */
-	uint64_t tb_rate;
-
-	/** Token bucket size (measured in credits) */
-	uint64_t tb_size;
-
-	/** Traffic class rates (measured in bytes per second) */
-	uint64_t tc_rate[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-
-	/** Enforcement period (measured in milliseconds) */
-	uint64_t tc_period;
+struct rte_sched_subport_params {
+	/* Subport token bucket */
+	uint32_t tb_rate;                /**< Rate (measured in bytes per second) */
+	uint32_t tb_size;                /**< Size (measured in credits) */
+
+	/* Subport traffic classes */
+	uint32_t tc_rate[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	/**< Traffic class rates (measured in bytes per second) */
+	uint32_t tc_period;
+	/**< Enforcement period for rates (measured in milliseconds) */
+};
 
-	/** Best-effort traffic class oversubscription weight */
-	uint8_t tc_ov_weight;
+/** Subport statistics */
+struct rte_sched_subport_stats {
+	/* Packets */
+	uint32_t n_pkts_tc[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	/**< Number of packets successfully written */
+	uint32_t n_pkts_tc_dropped[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	/**< Number of packets dropped */
+
+	/* Bytes */
+	uint32_t n_bytes_tc[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	/**< Number of bytes successfully written for each traffic class */
+	uint32_t n_bytes_tc_dropped[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	/**< Number of bytes dropped for each traffic class */
 
-	/** WRR weights of best-effort traffic class queues */
-	uint8_t wrr_weights[RTE_SCHED_BE_QUEUES_PER_PIPE];
+#ifdef RTE_SCHED_RED
+	uint32_t n_pkts_red_dropped[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	/**< Number of packets dropped by red */
+#endif
 };
 
 /*
- * Subport configuration parameters. The period and credits_per_period
+ * Pipe configuration parameters. The period and credits_per_period
  * parameters are measured in bytes, with one byte meaning the time
  * duration associated with the transmission of one byte on the
  * physical medium of the output port, with pipe or pipe traffic class
@@ -148,131 +150,63 @@ struct rte_sched_pipe_params {
  * credits_per_period divided by period. One credit represents one
  * byte.
  */
-struct rte_sched_subport_params {
-	/** Number of subport pipes.
-	 * The subport can enable/allocate fewer pipes than the maximum
-	 * number set through struct port_params::n_max_pipes_per_subport,
-	 * as needed, to avoid memory allocation for the queues of the
-	 * pipes that are not really needed.
-	 */
-	uint32_t n_pipes_per_subport_enabled;
-
-	/** Packet queue size for each traffic class.
-	 * All the pipes within the same subport share the similar
-	 * configuration for the queues.
-	 */
-	uint16_t qsize[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-
-	/** Pipe profile table.
-	 * Every pipe is configured using one of the profiles from this table.
-	 */
-	struct rte_sched_pipe_params *pipe_profiles;
-
-	/** Profiles in the pipe profile table */
-	uint32_t n_pipe_profiles;
-
-	/** Max allowed profiles in the pipe profile table */
-	uint32_t n_max_pipe_profiles;
-
-#ifdef RTE_SCHED_RED
-	/** RED parameters */
-	struct rte_red_params red_params[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE][RTE_COLORS];
+struct rte_sched_pipe_params {
+	/* Pipe token bucket */
+	uint32_t tb_rate;                /**< Rate (measured in bytes per second) */
+	uint32_t tb_size;                /**< Size (measured in credits) */
+
+	/* Pipe traffic classes */
+	uint32_t tc_rate[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	/**< Traffic class rates (measured in bytes per second) */
+	uint32_t tc_period;
+	/**< Enforcement period (measured in milliseconds) */
+#ifdef RTE_SCHED_SUBPORT_TC_OV
+	uint8_t tc_ov_weight;		 /**< Weight Traffic class 3 oversubscription */
 #endif
-};
-
-struct rte_sched_subport_profile_params {
-	/** Token bucket rate (measured in bytes per second) */
-	uint64_t tb_rate;
-
-	/** Token bucket size (measured in credits) */
-	uint64_t tb_size;
-
-	/** Traffic class rates (measured in bytes per second) */
-	uint64_t tc_rate[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
 
-	/** Enforcement period for rates (measured in milliseconds) */
-	uint64_t tc_period;
-};
-
-/** Subport statistics */
-struct rte_sched_subport_stats {
-	/** Number of packets successfully written */
-	uint64_t n_pkts_tc[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-
-	/** Number of packets dropped */
-	uint64_t n_pkts_tc_dropped[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-
-	/** Number of bytes successfully written for each traffic class */
-	uint64_t n_bytes_tc[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-
-	/** Number of bytes dropped for each traffic class */
-	uint64_t n_bytes_tc_dropped[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-
-#ifdef RTE_SCHED_RED
-	/** Number of packets dropped by red */
-	uint64_t n_pkts_red_dropped[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
-#endif
+	/* Pipe queues */
+	uint8_t  wrr_weights[RTE_SCHED_QUEUES_PER_PIPE]; /**< WRR weights */
 };
 
 /** Queue statistics */
 struct rte_sched_queue_stats {
-	/** Packets successfully written */
-	uint64_t n_pkts;
-
-	/** Packets dropped */
-	uint64_t n_pkts_dropped;
-
+	/* Packets */
+	uint32_t n_pkts;                 /**< Packets successfully written */
+	uint32_t n_pkts_dropped;         /**< Packets dropped */
 #ifdef RTE_SCHED_RED
-	/** Packets dropped by RED */
-	uint64_t n_pkts_red_dropped;
+	uint32_t n_pkts_red_dropped;	 /**< Packets dropped by RED */
 #endif
 
-	/** Bytes successfully written */
-	uint64_t n_bytes;
-
-	/** Bytes dropped */
-	uint64_t n_bytes_dropped;
+	/* Bytes */
+	uint32_t n_bytes;                /**< Bytes successfully written */
+	uint32_t n_bytes_dropped;        /**< Bytes dropped */
 };
 
 /** Port configuration parameters. */
 struct rte_sched_port_params {
-	/** Name of the port to be associated */
-	const char *name;
-
-	/** CPU socket ID */
-	int socket;
-
-	/** Output port rate (measured in bytes per second) */
-	uint64_t rate;
-
-	/** Maximum Ethernet frame size (measured in bytes).
-	 * Should not include the framing overhead.
-	 */
-	uint32_t mtu;
-
-	/** Framing overhead per packet (measured in bytes) */
-	uint32_t frame_overhead;
-
-	/** Number of subports */
-	uint32_t n_subports_per_port;
-
-	/** subport profile table.
-	 * Every pipe is configured using one of the profiles from this table.
-	 */
-	struct rte_sched_subport_profile_params *subport_profiles;
-
-	/** Profiles in the pipe profile table */
-	uint32_t n_subport_profiles;
-
-	/** Max allowed profiles in the pipe profile table */
-	uint32_t n_max_subport_profiles;
-
-	/** Maximum number of subport pipes.
-	 * This parameter is used to reserve a fixed number of bits
-	 * in struct rte_mbuf::sched.queue_id for the pipe_id for all
-	 * the subports of the same port.
-	 */
-	uint32_t n_pipes_per_subport;
+	const char *name;                /**< String to be associated */
+	int socket;                      /**< CPU socket ID */
+	uint32_t rate;                   /**< Output port rate
+					  * (measured in bytes per second) */
+	uint32_t mtu;                    /**< Maximum Ethernet frame size
+					  * (measured in bytes).
+					  * Should not include the framing overhead. */
+	uint32_t frame_overhead;         /**< Framing overhead per packet
+					  * (measured in bytes) */
+	uint32_t n_subports_per_port;    /**< Number of subports */
+	uint32_t n_pipes_per_subport;    /**< Number of pipes per subport */
+	uint16_t qsize[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE];
+	/**< Packet queue size for each traffic class.
+	 * All queues within the same pipe traffic class have the same
+	 * size. Queues from different pipes serving the same traffic
+	 * class have the same size. */
+	struct rte_sched_pipe_params *pipe_profiles;
+	/**< Pipe profile table.
+	 * Every pipe is configured using one of the profiles from this table. */
+	uint32_t n_pipe_profiles;        /**< Profiles in the pipe profile table */
+#ifdef RTE_SCHED_RED
+	struct rte_red_params red_params[RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE][RTE_COLORS]; /**< RED parameters */
+#endif
 };
 
 /*
@@ -308,8 +242,6 @@ rte_sched_port_free(struct rte_sched_por
  *
  * @param port
  *   Handle to port scheduler instance
- * @param subport_id
- *   Subport ID
  * @param params
  *   Pipe profile parameters
  * @param pipe_profile_id
@@ -317,59 +249,27 @@ rte_sched_port_free(struct rte_sched_por
  * @return
  *   0 upon success, error code otherwise
  */
-__rte_experimental
-int
-rte_sched_subport_pipe_profile_add(struct rte_sched_port *port,
-	uint32_t subport_id,
+int __rte_experimental
+rte_sched_port_pipe_profile_add(struct rte_sched_port *port,
 	struct rte_sched_pipe_params *params,
 	uint32_t *pipe_profile_id);
 
 /**
- * @warning
- * @b EXPERIMENTAL: this API may change without prior notice.
- *
- * Hierarchical scheduler subport bandwidth profile add
- * Note that this function is safe to use in runtime for adding new
- * subport bandwidth profile as it doesn't have any impact on hiearchical
- * structure of the scheduler.
- * @param port
- *   Handle to port scheduler instance
- * @param profile
- *   Subport bandwidth profile
- * @param subport_profile_id
- *   Subport profile id
- * @return
- *   0 upon success, error code otherwise
- */
-__rte_experimental
-int
-rte_sched_port_subport_profile_add(struct rte_sched_port *port,
-	struct rte_sched_subport_profile_params *profile,
-	uint32_t *subport_profile_id);
-
-/**
  * Hierarchical scheduler subport configuration
- * Note that this function is safe to use at runtime
- * to configure subport bandwidth profile.
+ *
  * @param port
  *   Handle to port scheduler instance
  * @param subport_id
  *   Subport ID
  * @param params
- *   Subport configuration parameters. Must be non-NULL
- *   for first invocation (i.e initialization) for a given
- *   subport. Ignored (recommended value is NULL) for all
- *   subsequent invocation on the same subport.
- * @param subport_profile_id
- *   ID of subport bandwidth profile
+ *   Subport configuration parameters
  * @return
  *   0 upon success, error code otherwise
  */
 int
 rte_sched_subport_config(struct rte_sched_port *port,
 	uint32_t subport_id,
-	struct rte_sched_subport_params *params,
-	uint32_t subport_profile_id);
+	struct rte_sched_subport_params *params);
 
 /**
  * Hierarchical scheduler pipe configuration
@@ -381,7 +281,7 @@ rte_sched_subport_config(struct rte_sche
  * @param pipe_id
  *   Pipe ID within subport
  * @param pipe_profile
- *   ID of subport-level pre-configured pipe profile
+ *   ID of port-level pre-configured pipe profile
  * @return
  *   0 upon success, error code otherwise
  */
@@ -394,16 +294,14 @@ rte_sched_pipe_config(struct rte_sched_p
 /**
  * Hierarchical scheduler memory footprint size per port
  *
- * @param port_params
+ * @param params
  *   Port scheduler configuration parameter structure
- * @param subport_params
- *   Array of subport parameter structures
  * @return
  *   Memory footprint size in bytes upon success, 0 otherwise
  */
 uint32_t
-rte_sched_port_get_memory_footprint(struct rte_sched_port_params *port_params,
-	struct rte_sched_subport_params **subport_params);
+rte_sched_port_get_memory_footprint(struct rte_sched_port_params *params);
+
 /*
  * Statistics
  *
@@ -420,9 +318,8 @@ rte_sched_port_get_memory_footprint(stru
  *   Pointer to pre-allocated subport statistics structure where the statistics
  *   counters should be stored
  * @param tc_ov
- *   Pointer to pre-allocated RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE-entry array
- *   where the oversubscription status for each of the subport traffic classes
- *   should be stored.
+ *   Pointer to pre-allocated 4-entry array where the oversubscription status for
+ *   each of the 4 subport traffic classes should be stored.
  * @return
  *   0 upon success, error code otherwise
  */
@@ -458,8 +355,6 @@ rte_sched_queue_read_stats(struct rte_sc
  * Scheduler hierarchy path write to packet descriptor. Typically
  * called by the packet classification stage.
  *
- * @param port
- *   Handle to port scheduler instance
  * @param pkt
  *   Packet descriptor handle
  * @param subport
@@ -467,16 +362,14 @@ rte_sched_queue_read_stats(struct rte_sc
  * @param pipe
  *   Pipe ID within subport
  * @param traffic_class
- *   Traffic class ID within pipe (0 .. RTE_SCHED_TRAFFIC_CLASS_BE)
+ *   Traffic class ID within pipe (0 .. 3)
  * @param queue
- *   Queue ID within pipe traffic class, 0 for high priority TCs, and
- *   0 .. (RTE_SCHED_BE_QUEUES_PER_PIPE - 1) for best-effort TC
+ *   Queue ID within pipe traffic class (0 .. 3)
  * @param color
  *   Packet color set
  */
 void
-rte_sched_port_pkt_write(struct rte_sched_port *port,
-			 struct rte_mbuf *pkt,
+rte_sched_port_pkt_write(struct rte_mbuf *pkt,
 			 uint32_t subport, uint32_t pipe, uint32_t traffic_class,
 			 uint32_t queue, enum rte_color color);
 
@@ -486,8 +379,6 @@ rte_sched_port_pkt_write(struct rte_sche
  * enqueue operation. The subport, pipe, traffic class and queue
  * parameters need to be pre-allocated by the caller.
  *
- * @param port
- *   Handle to port scheduler instance
  * @param pkt
  *   Packet descriptor handle
  * @param subport
@@ -495,14 +386,13 @@ rte_sched_port_pkt_write(struct rte_sche
  * @param pipe
  *   Pipe ID within subport
  * @param traffic_class
- *   Traffic class ID within pipe (0 .. RTE_SCHED_TRAFFIC_CLASS_BE)
+ *   Traffic class ID within pipe (0 .. 3)
  * @param queue
- *   Queue ID within pipe traffic class, 0 for high priority TCs, and
- *   0 .. (RTE_SCHED_BE_QUEUES_PER_PIPE - 1) for best-effort TC
+ *   Queue ID within pipe traffic class (0 .. 3)
+ *
  */
 void
-rte_sched_port_pkt_read_tree_path(struct rte_sched_port *port,
-				  const struct rte_mbuf *pkt,
+rte_sched_port_pkt_read_tree_path(const struct rte_mbuf *pkt,
 				  uint32_t *subport, uint32_t *pipe,
 				  uint32_t *traffic_class, uint32_t *queue);
 
--- a/lib/librte_sched/rte_sched_common.h
+++ b/lib/librte_sched/rte_sched_common.h
@@ -14,6 +14,12 @@ extern "C" {
 
 #define __rte_aligned_16 __rte_aligned(16)
 
+static inline uint32_t
+rte_sched_min_val_2_u32(uint32_t x, uint32_t y)
+{
+	return (x < y)? x : y;
+}
+
 #if 0
 static inline uint32_t
 rte_min_pos_4_u16(uint16_t *x)
--- a/lib/librte_sched/version.map
+++ b/lib/librte_sched/version.map
@@ -28,6 +28,7 @@ EXPERIMENTAL {
 	global:
 
 	rte_sched_subport_pipe_profile_add;
+	rte_sched_port_pipe_profile_add;
 	# added in 20.11
 	rte_sched_port_subport_profile_add;
 };
--- a/app/test/test_sched.c
+++ b/app/test/test_sched.c
@@ -20,42 +20,27 @@
 #define SUBPORT         0
 #define PIPE            1
 #define TC              2
-#define QUEUE           0
-#define MAX_SCHED_SUBPORT_PROFILES  8
+#define QUEUE           3
 
-static struct rte_sched_pipe_params pipe_profile[] = {
-	{ /* Profile #0 */
-		.tb_rate = 305175,
-		.tb_size = 1000000,
-
-		.tc_rate = {305175, 305175, 305175, 305175, 305175, 305175,
-			305175, 305175, 305175, 305175, 305175, 305175, 305175},
-		.tc_period = 40,
-		.tc_ov_weight = 1,
-
-		.wrr_weights = {1, 1, 1, 1},
-	},
-};
-
-static struct rte_sched_subport_profile_params
-		subport_profile[] = {
+static struct rte_sched_subport_params subport_param[] = {
 	{
 		.tb_rate = 1250000000,
 		.tb_size = 1000000,
-		.tc_rate = {1250000000, 1250000000, 1250000000, 1250000000,
-			1250000000, 1250000000, 1250000000, 1250000000, 1250000000,
-			1250000000, 1250000000, 1250000000, 1250000000},
+
+		.tc_rate = {1250000000, 1250000000, 1250000000, 1250000000},
 		.tc_period = 10,
 	},
 };
 
-static struct rte_sched_subport_params subport_param[] = {
-	{
-		.n_pipes_per_subport_enabled = 1024,
-		.qsize = {32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32},
-		.pipe_profiles = pipe_profile,
-		.n_pipe_profiles = 1,
-		.n_max_pipe_profiles = 1,
+static struct rte_sched_pipe_params pipe_profile[] = {
+	{ /* Profile #0 */
+		.tb_rate = 305175,
+		.tb_size = 1000000,
+
+		.tc_rate = {305175, 305175, 305175, 305175},
+		.tc_period = 40,
+
+		.wrr_weights = {1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1},
 	},
 };
 
@@ -65,10 +50,10 @@ static struct rte_sched_port_params port
 	.mtu = 1522,
 	.frame_overhead = RTE_SCHED_FRAME_OVERHEAD_DEFAULT,
 	.n_subports_per_port = 1,
-	.n_subport_profiles = 1,
-	.subport_profiles = subport_profile,
-	.n_max_subport_profiles = MAX_SCHED_SUBPORT_PROFILES,
 	.n_pipes_per_subport = 1024,
+	.qsize = {32, 32, 32, 32},
+	.pipe_profiles = pipe_profile,
+	.n_pipe_profiles = 1,
 };
 
 #define NB_MBUF          32
@@ -91,7 +76,7 @@ create_mempool(void)
 }
 
 static void
-prepare_pkt(struct rte_sched_port *port, struct rte_mbuf *mbuf)
+prepare_pkt(struct rte_mbuf *mbuf)
 {
 	struct rte_ether_hdr *eth_hdr;
 	struct rte_vlan_hdr *vlan1, *vlan2;
@@ -99,14 +84,10 @@ prepare_pkt(struct rte_sched_port *port,
 
 	/* Simulate a classifier */
 	eth_hdr = rte_pktmbuf_mtod(mbuf, struct rte_ether_hdr *);
-	vlan1 = (struct rte_vlan_hdr *)(&eth_hdr->ether_type);
-	vlan2 = (struct rte_vlan_hdr *)(
-		(uintptr_t)&eth_hdr->ether_type + sizeof(struct rte_vlan_hdr));
-	eth_hdr = (struct rte_ether_hdr *)(
-		(uintptr_t)&eth_hdr->ether_type +
-		2 * sizeof(struct rte_vlan_hdr));
-	ip_hdr = (struct rte_ipv4_hdr *)(
-		(uintptr_t)eth_hdr + sizeof(eth_hdr->ether_type));
+	vlan1 = (struct rte_vlan_hdr *)(&eth_hdr->ether_type );
+	vlan2 = (struct rte_vlan_hdr *)((uintptr_t)&eth_hdr->ether_type + sizeof(struct rte_vlan_hdr));
+	eth_hdr = (struct rte_ether_hdr *)((uintptr_t)&eth_hdr->ether_type + 2 *sizeof(struct rte_vlan_hdr));
+	ip_hdr = (struct rte_ipv4_hdr *)((uintptr_t)eth_hdr +  sizeof(eth_hdr->ether_type));
 
 	vlan1->vlan_tci = rte_cpu_to_be_16(SUBPORT);
 	vlan2->vlan_tci = rte_cpu_to_be_16(PIPE);
@@ -114,8 +95,7 @@ prepare_pkt(struct rte_sched_port *port,
 	ip_hdr->dst_addr = RTE_IPV4(0,0,TC,QUEUE);
 
 
-	rte_sched_port_pkt_write(port, mbuf, SUBPORT, PIPE, TC, QUEUE,
-					RTE_COLOR_YELLOW);
+	rte_sched_port_pkt_write(mbuf, SUBPORT, PIPE, TC, QUEUE, RTE_COLOR_YELLOW);
 
 	/* 64 byte packet */
 	mbuf->pkt_len  = 60;
@@ -147,10 +127,10 @@ test_sched(void)
 	port = rte_sched_port_config(&port_param);
 	TEST_ASSERT_NOT_NULL(port, "Error config sched port\n");
 
-	err = rte_sched_subport_config(port, SUBPORT, subport_param, 0);
+	err = rte_sched_subport_config(port, SUBPORT, subport_param);
 	TEST_ASSERT_SUCCESS(err, "Error config sched, err=%d\n", err);
 
-	for (pipe = 0; pipe < subport_param[0].n_pipes_per_subport_enabled; pipe++) {
+	for (pipe = 0; pipe < port_param.n_pipes_per_subport; pipe ++) {
 		err = rte_sched_pipe_config(port, SUBPORT, pipe, 0);
 		TEST_ASSERT_SUCCESS(err, "Error config sched pipe %u, err=%d\n", pipe, err);
 	}
@@ -158,7 +138,7 @@ test_sched(void)
 	for (i = 0; i < 10; i++) {
 		in_mbufs[i] = rte_pktmbuf_alloc(mp);
 		TEST_ASSERT_NOT_NULL(in_mbufs[i], "Packet allocation failed\n");
-		prepare_pkt(port, in_mbufs[i]);
+		prepare_pkt(in_mbufs[i]);
 	}
 
 
@@ -175,7 +155,7 @@ test_sched(void)
 		color = rte_sched_port_pkt_read_color(out_mbufs[i]);
 		TEST_ASSERT_EQUAL(color, RTE_COLOR_YELLOW, "Wrong color\n");
 
-		rte_sched_port_pkt_read_tree_path(port, out_mbufs[i],
+		rte_sched_port_pkt_read_tree_path(out_mbufs[i],
 				&subport, &pipe, &traffic_class, &queue);
 
 		TEST_ASSERT_EQUAL(subport, SUBPORT, "Wrong subport\n");
