--- a/lib/librte_sched/rte_approx.c
+++ b/lib/librte_sched/rte_approx.c
@@ -3,7 +3,7 @@
  */
 
 #include <stdlib.h>
-
+#include <rte_log.h>
 #include "rte_approx.h"
 
 /*
@@ -165,3 +165,52 @@ int rte_approx(double alpha, double d, u
 	/* Perform approximation */
 	return find_best_rational_approximation(alpha_num, d_num, denum, p, q);
 }
+
+static
+int rte_approx_get(uint32_t numerator, uint32_t denominator, uint32_t burst,
+		   uint32_t *p, uint32_t *q)
+{
+	uint32_t d = 1;
+
+	/*
+	 * We need to restrict the numerator value returned so that it's
+	 * less than the shaper burst.  If it exceeds it when we add tokens
+	 * the value will be reset to the burst thereby reducing the tokens
+	 * which results in a shaper shortfall.
+	 */
+
+	uint32_t denum = burst;
+	uint32_t alpha = ((uint64_t) numerator * (uint64_t) denum) /
+				denominator;
+	int rv;
+
+	while (alpha < 4 && denum > 1) {
+		denum <<= 1;
+		alpha = ((uint64_t) numerator * (uint64_t) denum) / denominator;
+	}
+
+	/*
+	 * The following is required to avoid find_best_rational_approximation's
+	 * input argument checking.
+	 */
+	alpha = alpha - d;
+
+	/* Perform approximation */
+	rv = find_best_rational_approximation(alpha, d, denum, p, q);
+	if (rv) {
+		RTE_LOG(ERR, SCHED,
+			"numer: %u, denominator: %u, alpha: %u, denum: %u\n",
+			numerator, denominator, alpha, denum);
+	}
+	return rv;
+}
+
+int rte_approx_int(uint32_t numerator, uint32_t denominator,
+		   uint32_t *p, uint32_t *q)
+{
+	/*
+	 * The best value proved to be 16383 from the following range tried:
+	 * 13131, 16383, 17467, 32003, 48017, 64007, 93931 and 131317
+	 */
+	return rte_approx_get(numerator, denominator, 16383, p, q);
+}
--- a/lib/librte_sched/rte_approx.h
+++ b/lib/librte_sched/rte_approx.h
@@ -39,6 +39,25 @@ extern "C" {
  */
 int rte_approx(double alpha, double d, uint32_t *p, uint32_t *q);
 
+/**
+ * Find best rational approximation using integers
+ *
+ * @param alpha_num
+ *   Numerator for the rational number calculation
+ * @param denum
+ *   Denominator for the rational number calculation
+ * @param p
+ *   Pointer to pre-allocated space where the numerator of the rational
+ *   approximation will be stored when operation is successful
+ * @param q
+ *   Pointer to pre-allocated space where the denominator of the rational
+ *   approximation will be stored when operation is successful
+ * @return
+ *   0 upon success, error code otherwise
+ */
+int __rte_experimental
+rte_approx_int(uint32_t alpha_num, uint32_t denum, uint32_t *p, uint32_t *q);
+
 #ifdef __cplusplus
 }
 #endif
--- a/lib/librte_sched/rte_sched.c
+++ b/lib/librte_sched/rte_sched.c
@@ -681,15 +681,18 @@ rte_sched_pipe_profile_convert(struct rt
 		dst->tb_credits_per_period = 1;
 		dst->tb_period = 1;
 	} else {
-		double tb_rate = (double) src->tb_rate
-				/ (double) rate;
-		double d = RTE_SCHED_TB_RATE_CONFIG_ERR;
-
-		rte_approx(tb_rate, d,
+		rte_approx_int(src->tb_rate, rate,
 			&dst->tb_credits_per_period, &dst->tb_period);
 	}
 
+	/*
+	 * The period must be less than or equal to the burst otherwise
+	 * we lose a bunch of tokens every period because the maximum
+	 * the token bucket is allowed to be is the burst.
+	 */
 	dst->tb_size = src->tb_size;
+	if (dst->tb_credits_per_period > dst->tb_size)
+		dst->tb_size = dst->tb_credits_per_period;
 
 	/* Traffic Classes */
 	dst->tc_period = rte_sched_time_us_to_bytes(src->tc_period,
@@ -1040,13 +1043,18 @@ rte_sched_subport_config_common(struct r
 		s->tb_credits_per_period = 1;
 		s->tb_period = 1;
 	} else {
-		double tb_rate = ((double) params->tb_rate) / ((double) port->rate);
-		double d = RTE_SCHED_TB_RATE_CONFIG_ERR;
-
-		rte_approx(tb_rate, d, &s->tb_credits_per_period, &s->tb_period);
+		rte_approx_int(params->tb_rate, port->rate,
+			       &s->tb_credits_per_period, &s->tb_period);
 	}
 
+	/*
+	 * The period must be less than or equal to the burst otherwise
+	 * we lose a bunch of tokens every period because the maximum
+	 * the token bucket is allowed to be is the burst.
+	 */
 	s->tb_size = params->tb_size;
+	if (s->tb_credits_per_period > s->tb_size)
+		s->tb_size = s->tb_credits_per_period;
 	s->tb_time = port->time;
 	s->tb_credits = s->tb_size / 2;
 
